MODELOS AVANZADOS DE COMPUTACION Manual practico sobre decibilidad y semidecibilidad Es decidible. Disenar un algoritmo que resuelva el problema. Normalmente, esto se demuestra probando que el problema se reduce a realizar un numero ﬁnito de comproba- ciones (aunque, a priori, no lo parezca), cada una de ellas en un numero ﬁnito de pasos. Entonces, una maquina de Turing que compruebe todas las posibilidades es un algoritmo que resuelve el problema (siempre para, ya que realiza un numero ﬁnito de pasos). teorema de Rice: Teorema 1.1 (Teorema de Rice) Toda propiedad no trivial de los lenguajes recursi- que solo depende del lenguaje en sı y que es independiente de las diferentes maquinas de Dada un MT M, determinar si M acepta una palabra que empiece por 0, la propiedad aceptar una palabra que empieza por 0 es una propiedad de los lenguajes recursivamente enumerables, porque es una propiedad que solo depende de L(M). Dicho de otra manera, si otra maquina de Turing M(cid:48) acepta el mismo lenguaje, M cumple esa propiedad si, y solo si, lo hace M(cid:48). Dada un MT M, determinar si M acepta una palabra en menos de 5 movimientos, la propiedad acepta una palabra en menos de 5 movimientos no es una propiedad de los lenguajes recursivamente enumerables. Es una propiedad asociada a las maquinas de Turing ya que, para dos maquinas de Turing que acepten el mismo lenguaje, una puede La propiedad ser aceptado por una maquina de Turing es trivial, todos los lengua- La propiedad existe una reduccion de Ld a L es trivial, ningun lenguaje r.e. L lo cumple (porque si no, no serıa r.e.). La propiedad ser numerable es trivial, todos los lenguajes son numerables. Si la propiedad no es de los lenguajes r.e., entonces necesitamos establecer una reduccion desde un problema no decidible. Algunos problemas que se pueden utilizar para esto son: UNIVERSAL: Dada una MT M y una entrada w, determinar si M acepta w. El PARADA: Dada una MT M y una entrada w, determinar si M para con entrada w. C-DIAGONAL: Dada una MT M, determinar si M acepta su codiﬁcacion (cid:104)M(cid:105). En general, cualquier problema visto en clase que no sea decidible. Es semidecidible. Disenar una maquina de Turing que acepte las palabras del lenguaje requieren comprobar que, en un conjunto inﬁnito A (si es ﬁnito, ademas, es decidible) existe un elemento que cumple cierta propiedad. En este caso, la maquina de Turing no determinista sigue el siguiente esquema: Maquina de Turing no determinista generica Entrada: Propiedad P, conjunto de posibilidades A 1: Seleccionamos de forma no determinista a A 2: Si a cumple la propiedad P entonces 3: 4: Si no 5: Obviamente, esto se puede extender a que existan un numero ﬁnito n de elementos que cumplan esa propiedad P. Bastarıa seleccionar de forma no determinista n elementos No es semidecidible. Establecer una reduccion desde un problema que sabemos que no es semidecidible. Algunos problemas que se pueden utilizar para esto son: DIAGONAL: Dada una MT M, determinar si M no acepta su codiﬁcacion (cid:104)M(cid:105). El lenguaje asociado es el lenguaje de diagonalizacion Ld. C-UNIVERSAL: Dada una MT M y una entrada w, determinar si M no acepta w. EMPTY: Dada una MT M, determinar si L(M) . El lenguaje asociado es Le. En general, el complementario de cualquier problema visto en clase que sea semide- Otra forma de demostrar que un problema/lenguaje no es semidecidible, es demostrar siempre es {0,1}. Ejemplo 2.1 Dadas dos maquinas de Turing M1 y M2, determinar si L(M1) L(M2). Solucion. Este problema necesita comprobar si TODA palabra de L(M1) (posiblemente un numero inﬁnito) esta en L(M2), por lo que deberıamos intuir que no es semidecible. Para demostrar esto vamos a realizar una reduccion desde un problema que no es semidecible, por lo que nuestro problema tampoco lo sera. Consideramos los problemas: P1: Dada una maquina de Turing M, determinar si L(M) . P2: Dadas dos maquinas de Turing M1 y M2, determinar si L(M1) L(M2). Sabemos, por las transparencias de teorıa, que P1 no es semidecidible, ya que es el problema Una reduccion de P1 a P2, P1 P2, consiste en asociar a cada instancia de P1 (una maquina de Turing) una instancia de P2 (dos maquinas de Turing) mediante un algoritmo F, de manera que si M es una instancia positiva del problema P1, entonces F(M) es una instancia positiva de P2, y, al contrario, si M es una instancia negativa del problema P1, entonces F(M) Consideramos la maquina de Turing R ({q0},{0,1},{0,1,},δ,q0,,), donde δ no tiene transiciones, por lo que L(R) (se puede considerar cualquier MT que no acepte palabras). Entonces, dada una instancia M de P1, le asociamos el par F(M) (M,R). Obviamente, esto es un proceso algorıtmico. Basta con escribir la codiﬁcacion de R despues de la codiﬁcacion de cualquier entrada M. Ademas, Si M es un caso positivo de P1, es decir, L(M) , entonces F(M) (M,R) es un caso positivo de P2, ya que L(M) L(R) . Si M es un caso negativo de P1, es decir, L(M) (cid:54) , entonces F(M) (M,R) es un caso negativo de P2, ya que L(M) (cid:54) L(R) . Ejemplo 2.2 Dado un automata con pila no determinista y una palabra de entrada, determinar si el automata acepta la palabra. Solucion. Este problema es decidible ya que podemos disenar un algoritmo que lo resuelva. Supongamos que P es un automata con pila y u, una palabra. Como vimos en la asignatura Modelos de Computacion (Tema 5 de teorıa) existe un algoritmo que calcula una gramatica libre de contexto G que genera el mismo lenguaje que acepta P. En el Tema 4 de teorıa de Modelos de Computacion se explica un algoritmo que elimina producciones nulas de una gramatica libre de contexto. Se lo aplicamos a G y obtenemos una gramatica G(cid:48) que genera las mismas palabras que G, salvo la palabra vacıa en caso de que G genere (cid:15). Si la palabra u es la palabra vacıa, basta con comprobar si el sımbolo inicial es anulable. Si lo es, entonces se acepta, y si no, no se acepta. Si la palabra u no es la palabra vacıa, aplicamos el algoritmo de eliminacion de producciones unitarias y obtenemos una gramatica G(cid:48)(cid:48) equivalente a G(cid:48) pero sin producciones unitarias. Entonces G(cid:48)(cid:48) esta en las condiciones para aplicar el algoritmo de calculo de la forma normal de Chomsky (Tema 4 de teorıa de Modelos de Computacion), y obtenemos una gramatica C equivalente a G(cid:48)(cid:48) en la forma normal de Chomsky. A C y a u se le puede aplicar ahora el algoritmo de Cocke-Younger-Kasami (Tema 6 de teorıa de Modelos de Computacion) que nos asegura si C genera u, o no. Por tanto, decide si P acepta u, o no. Ejemplo 2.3 Dada una maquina de Turing, determinar si acepta una palabra de longitud Solucion. Ya que se trata de un problema de comprobar la existencia de algo, deberıamos intuir que este problema no es decidible pero sı semidecidible. recursivamente enumerables. Se puede observar que aceptar una palabra de longitud menor o igual a 20 es una propiedad del lenguaje aceptado por la maquina de Turing, no de la maquina de Turing en sı. Dicho de otra manera, si dos maquinas de Turing acepta el mismo lenguaje, una acepta una palabra de longitud menor o igual a 20 si y solo si lo hace la otra. Por tanto, Para demostrar que es semidecidible, podemos construir una maquina de Turing no de- terminista R que acepte la codiﬁcacion de las maquinas de Turing que cumple esa propiedad (se entiende que si la cadena de entrada no es la codiﬁcacion de una maquina de Turing, se rechaza). Maquina de Turing no determinista R Entrada: La codiﬁcacion (cid:104)M(cid:105) de una maquina de Turing M 1: Anadimos la palabra 111 al ﬁnal de la entrada 2: De forma no determinista seleccionamos una palabra u de longitud menor que o igual que 20 y la copiamos a continuacion de 3: Ejecutamos la maquina universal sobre la palabra de la cinta, es decir, sobre (cid:104)M(cid:105)111u 4: Si la maquina universal acepta entonces 5: R acepta 6: Si no 7: R no acepta Vemos que basta con que alguna de las ramas de computo (al realizar la eleccion no deter- minista de la lınea 2) se acepte para que la entrada se acepte, que es precisamente lo que nos pide el problema: ¿Existe una palabra...?. Otra forma de resolverlo es describiendo una maquina determinista. Primero, una propuesta que NO es valida: Maquina de Turing determinista S QUE NO FUNCIONA Entrada: La codiﬁcacion (cid:104)M(cid:105) de una maquina de Turing M 1: Anadimos la palabra 111 al ﬁnal de la entrada 2: Puesto que las palabras de longitud 20 o menos son un conjunto ﬁnito, llamemoslo A, las 3: Para cada palabra u A, en el orden establecido, hacer 4: Copio (cid:104)M(cid:105)111u en una segunda cinta 5: Ejecutamos la maquina universal sobre la segunda cinta 6: Si la maquina universal acepta entonces 7: 8: S rechaza la entrada (ya que no se ha aceptado ninguna entrada en el bucle) ¿Por que no funciona? Porque es posible que para alguna palabra u de A, al ejecutar la maquina universal (lınea 5), esta se rechace al estar indeﬁnidamente en movimiento (la maquina universal cicle con esa entrada). Por tanto, la maquina disenada S tambien ciclarıa en esa pasada del bucle (en la lınea 5), y rechazarıa la entrada (la salida dirıa que M no acepta palabras de longitud menor que 21). Sin embargo podrıa no haber ejecutado todas las pasadas del bucle, es decir, faltarıan algunas palabras de A por comprobar, y es posible que alguna de ellas sı es ¿Como arreglar esto? Ejecutando todas las palabras de A a la vez. Como no podemos realizar una seleccion no determinista, lo que vamos a hacer es ejecutar un numero ﬁnito de pasos de calculo con todas las palabras. Si con ninguna se acepta, aumentamos el numero de pasos de calculo y repetimos. Ası de forma indeﬁnida hasta que una palabra se acepte (que se aceptara en un numero ﬁnito de pasos de calculo). Si, en realidad, la maquina M no acepta ninguna palabra de A, nuestra nueva maquina ciclara indeﬁnidamente (ya que es un bucle inﬁnito) Maquina de Turing determinista S Entrada: La codiﬁcacion (cid:104)M(cid:105) de una maquina de Turing M 1: Anadimos la palabra 111 al ﬁnal de la entrada 2: Puesto que las palabras de longitud 20 o menos son un conjunto ﬁnito, llamemoslo A, las 3: Para i 1,2,3,...., hacer 4: Para cada palabra u A, en el orden establecido, hacer 5: Copio (cid:104)M(cid:105)111u en una segunda cinta 6: Ejecutamos la maquina universal i pasos sobre la segunda cinta 7: Si la maquina universal acepta entonces 8: Una forma de ver la diferencia entre ambas maquinas es pensar en el arbol de pasos de computo. La primera maquina, que no resuelve correctamente el problema, realiza una busqueda en profundidad en los pasos de computo de todas las palabras de longitud menor que 21, ver Figura 1. Como hay una rama inﬁnita, la busqueda en profundidad no es capaz de visitar todos los nodos del arbol. Observese que la maquina M cicla con la palabra 2, por lo que nunca llega a veriﬁcar la palabra 3, que es la que sı acepta. Sin embargo, la segunda maquina realiza una busqueda en anchura, ver Figura 2. Puesto que, si alguna palabra se acepta, el nodo de aceptacion debe estar a profundidad ﬁnita, esta busqueda nos asegura que llegaremos a dicho nodo. Ejemplo 2.4 Dada un maquina de Turing M, determinar si, para cualquier entrada, M para antes de 10 pasos de calculo. Figure 1: Busqueda en profundidad Figure 2: Busqueda en anchura Solucion. Primero vamos a describir algunos errores muy comunes al resolver este ejercicio. maquinas de Turing. Un mismo lenguaje puede ser aceptado por dos maquinas de Turing, una que lo acepte para toda palabra en menos de 10 pasos, y otra en mas de 10 para alguna palabra. Ası que no se puede aplicar el teorema de Rice. ERROR 2. Es decidible. Este serıa el algoritmo: simplemente, para cada entrada, se ejecuta la maquina 10 pasos. Si no se para, entonces la respuesta es no. Si para para todas, la respuesta es sı. En este caso, el problema es que hay un numero inﬁnito de palabras a comprobar. Dada una maquina de Turing M, supongamos que comprobamos las palabras en el orden total dado en clase teorıa (primero se mira la longitud, y si tienen la misma, lexicograﬁcamente). Si existe una palabra que hace que la maquina se ejecute mas de 10 pasos, como tendra una longitud ﬁnita, llegara un momento en el que se compruebe que efectivamente, no se para con solo 10 pasos, y la respuesta para M es no. El problema viene si es una maquina que realmente se para siempre antes de 10 pasos. Este procedimiento estara comprobando La respuesta correcta es que es decidible. En 10 pasos, solo se pueden leer 10 casillas de la cinta como maximo. Ası que, para cualquier palabra (da igual la longitud), solo me interesan los 10 primeros sımbolos. Dadas dos palabras u1 y u2 con los 10 primeros sımbolos iguales, M de entrada. Por tanto, solo necesitamos comprobarlo para las palabras de longitud 10 o menos. Este conjunto es ﬁnito (tiene 210 elementos), ası que basta ejecutar 10 pasos para cada una de estas palabras. Si con todas para, entonces la respuesta es sı. Si alguna no ha parado, la Ejemplo 2.5 Dada un maquina de Turing M, determinar si para para cualquier entrada. Solucion. El problema no es semidecidible. Construimos una reduccion desde el complemen- universal. Puesto que se ha demostrado en teorıa que Lu es semidecidible pero no decidible, Lu no es semidecidible. Consideramos los problemas: C-UNIVERSAL: Dada una MT M y una palabra w, determinar si M no acepta w. ALG: Dada una MT M, determinar si para para cualquier entrada. Vamos a construir un proceso algorıtmico F para pasar de una instancia de C-UNIVERSAL a una instancia de ALG. Sea (M,w) una instancia de C-UNIVERSAL, construimos las siguiente maquina de Turing F(M,w) (que es una instancia de ALG) Maquina de Turing F(M,w) Entrada: Una palabra v {0,1} 1: Calculamos la longitud de v, y se almacena v en una segunda cinta 2: Borramos v de la primera cinta y copiamos en ella (cid:104)M(cid:105)111w 3: Simulamos v pasos de la maquina de Turing M con la entrada w 4: Si M acepta w en v pasos entonces 5: 6: Si no 7: Es claro que F es un algoritmo. Ademas, Si (M,w) es un caso positivo de C-UNIVERSAL, es decir, M no acepta w, entonces F(M,w) acepta cualquier entrada v (ya que M no acepta w para cualquier numero de pa- sos). Entonces L(F(M,w)) {0,1} y, como consecuencia, F(M,w) para para cualquier palabra de entrada. Por lo que F(M,w) es un caso positivo de ALG. Si (M,w) es un caso negativo de C-UNIVERSAL, entonces M acepta w. Supongamos dicha entrada, F(M,w) cicla. Por tanto, existe una entrada en la que no para y F(M,w) Ejemplo 2.6 Dada un maquina de Turing M, determinar si no acepta ningun palındromo. Solucion. Este problema no es semidecidible. Para demostrarlo, en vez de utilizar una re- duccion, estudiaremos el problema complementario. Consideramos el problema C-PAL: Dada un maquina de Turing M, determinar si M acepta un palındromo. Aceptar un palındromo es una propiedad no trivial de los lenguajes recursivamente enumerables (por ejemplo, {11} sı la cumple pero {10}, no). Por el teorema de Rice, C-PAL no es decidible. Para demostrar que es semidecidible, utilizamos la siguiente maquina de Turing no determinista Maquina de Turing no determinista Entrada: Una maquina de Turing (cid:104)M(cid:105) (su codiﬁcacion) 1: Seleccionamos de forma no determinista una palabra w {0,1} 2: Comprobamos si w es un palındromo 3: Si w es un palındromo entonces 4: 5: 6: 7: 8: 9: Si no 10: Una maquina de Turing determinista que acepte el mismo lenguaje podrıa ser la siguiente. Maquina de Turing determinista Entrada: Una maquina de Turing (cid:104)M(cid:105) (su codiﬁcacion) 1: Para i 1,2,3,..., hacer 2: Consideramos el conjunto Ai de la palabras de longitud menor que i (ﬁnito) 3: Para cada palabra a Ai hacer 4: Si a es un palındromo entonces 5: 6: 7: Ejemplo 2.7 Dada un maquina de Turing M, determinar si termina escribiendo un 1 cuando Solucion. En este caso, no podemos utilizar el teorema de Rice. Esta propiedad no es una propiedad de los lenguajes recursivamente enumerables. Un mismo lenguaje puede tener MTs que lo aceptan que escriban un 1 cuando empiezan con la cinta vacıa, y otras que no. Con- struimos entonces una reduccion desde el problema universal. Consideramos los siguientes problemas: UNIVERSAL: Dada una maquina de Turing M y una palabra w, determinar si M acepta w. ESC-1: Dada una MT M, determinar si escribe un 1 cuando la entrada es (cid:15). Vamos a construir un proceso algorıtmico F para pasar de una instancia de UNIVERSAL a una instancia de ESC-1. Sea (M,w) una instancia de UNIVERSAL, construimos las siguiente maquina de Turing F(M,w) (que es una instancia de ESC-1) Maquina de Turing F(M,w) Entrada: Una palabra v {0,1} 1: Si v no es (cid:15) entonces 2: 3: Si no 4: Realizamos una copia M(cid:48) de M donde el sımbolo 1 se ha sustituido por un sımbolo 1 (en el alfabeto de entrada, de la cinta, en las trasiciones, etc) 5: Llamamos w(cid:48) a la palabra w sustituyendo los 1 por 1 6: Escribimos (cid:104)M(cid:48)(cid:105)111w(cid:48) 7: Simulamos M(cid:48) con entrada w(cid:48) 8: Si M(cid:48) acepta w(cid:48) (observad que M(cid:48) acepta w(cid:48) si, y solo si, M acepta w) entonces 9: Es claro que F es un algoritmo. Ademas, Si M acepta w, entonces F(M,w) escribe un 1 cuando comienza con la cinta vacıa, porque M(cid:48) acepta w(cid:48). Si M no acepta w, entonces M(cid:48) no acepta w(cid:48) y nunca escribe 1 (ya que F(M,w) solo puede escribir 1). Entonces UNIVERSAL se reduce a ESC-1, por lo que ESC-1 no es decidible. Sin embargo, sı Maquina de Turing Entrada: Una maquina de Turing M 1: Para i 1,2,... hacer 2: Simular M con entrada (cid:15) un numero i de pasos 3: 4: Ejemplo 2.8 Dada un maquina de Turing M, determinar si acepta un numero inﬁnito de Solucion. El problema no es semidecidible. Realizamos una reduccion desde el problema diagonal. Consideramos los problemas: DIAGONAL: Dada una maquina de Turing M, determinar si M no acepta (cid:104)M(cid:105). INFINITY: Dada una MT M, determinar si acepta un numero inﬁnito de palabras. Vamos a construir un proceso algorıtmico F para pasar de una instancia de DIAGONAL a maquina de Turing F(M): Maquina de Turing F(M) Entrada: Una palabra v {0,1} 1: Si v no es de la forma 0n con n 0 entonces 2: 3: Si v 0n para cierto n 0 entonces 4: Simulamos M con entrada (cid:104)M(cid:105) un numero n de pasos 5: Si M acepta (cid:104)M(cid:105) entonces 6: 7: 8: Es claro que F es un algoritmo. Ademas, si M es un caso positivo de DIAGONAL, entonces M no acepta (cid:104)M(cid:105). Calculamos L(F(M)) el lenguaje aceptado por F(M). Dada una palabra v {0,1}: si v (cid:54) 0n para algun n 0, entonces la rechaza. si v 0n para algun n 0, ejecuta M (con entrada (cid:104)M(cid:105)) n pasos, y no la acepta (ya que M no acepta (cid:104)M(cid:105)), por lo que F(M) sı acepta v. Es decir, L(F(M)) 0, que tiene un numero inﬁnito de palabras. Luego F(M) es un Si M es un caso negativo de DIAGONAL, entonces M acepta (cid:104)M(cid:105). Supongamos que lo acepta en t pasos. Calculamos L(F(M)) el lenguaje aceptado por F(M). Dada una palabra v {0,1}: si v (cid:54) 0n para algun n 0, entonces la rechaza. si v 0n para algun n t, ejecuta M (con entrada (cid:104)M(cid:105)) n pasos, y no la acepta (ya que M acepta (cid:104)M(cid:105) en t pasos), por lo que F(M) sı acepta v. si v 0n para algun n t, ejecuta M (con entrada (cid:104)M(cid:105)) n pasos, y sı la acepta (ya que M acepta (cid:104)M(cid:105) en t pasos), por lo que F(M) rechaza v. Es decir, L(F(M)) {0,02,...,0t1, que tiene un numero ﬁnito de palabras. Luego F(M) es un caso negativo de INFINITY.