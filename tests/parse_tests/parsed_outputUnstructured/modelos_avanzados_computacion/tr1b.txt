Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables (Parte 2) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Máquinas de Turing Lenguajes recursivamente enumerables. Lenguajes recursivos Técnicas de construcción de Máquinas de Turing: memoria adicional, pistas múltiples, subrutinas Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Un problema PROBLEMA(x) ó PROBLEMA consta de: Un conjunto X de entradas. Un elemento x X se llama una entrada. Un conjunto Y de solución. Un elemento y Y se llama una solución. Una aplicación F : X 2Y que asigna a cada entrada x X un conjunto A Y de soluciones posibles. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Un problema PROBLEMA(x) ó PROBLEMA consta de: Un conjunto X de entradas. Un elemento x X se llama una entrada. Un conjunto Y de solución. Un elemento y Y se llama una solución. Una aplicación F : X 2Y que asigna a cada entrada x X un conjunto A Y de soluciones posibles. Búsqueda de caminos en grafos dirigidos: Entradas X: conjunto formado por las tripletas (G,ns,nl), donde G es un grafo dirigido, ns es un nodo de salida, nl es un nodo de llegada. Conjunto Y: lista de nodos (n1,...,nk) F(G,ns,nl) es el conjunto de las listas de nodos (n1,...,nk) tales que n1 ns,nk nl y todas las parejas (ni,ni1) sean arcos de G. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables ¿Qué es un algoritmo? En esta asignatura vamos a considerar dos conceptos que son equivalentes: Un programa en Phyton (Ph) bien escrito sintácticamente y con, al menos, una función deﬁnida, la primera de las cuales es la función principal (más adecuados para una resolución efectiva de problemas). Una Máquina de Turing (MT) que deﬁniremos en el siguiente tema (más adecuadas para el razonamientos teórico-matemáticos). Un algoritmo ALG resuelve un problema PROBLEMA(x) cuando el argumento de dicho algoritmo es un elemento x X y ALG(x) es un y F(x) o dice No hay Solución si F(x) /0. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables A partir de ahora, en términos generales hablaremos sólo sobre problemas en las que las entradas y las salidas son palabras sobre un alfabeto (Problema Computacional), aunque al hablar de un problema concreto hablaremos de grafos, números u otros elementos. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Puede haber palabras que no sean una codiﬁcación correcta de una entrada del problema original. En ese caso, supondremos que a esa entrada le corresponde una salida especial: NO. En general, nuestro estudio teórico se hará sobre problemas computacionales, pero su resultado se aplicará también a problemas en general, ya que estos resultados no dependerán de la codiﬁcación elegida (siempre que ésta sea razonable). Si tenemos un problema y un sistema de codiﬁcación, para cada entrada x, la codiﬁcación de x, se denotará como x (el elemento entre ángulos). Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Grafo: a,b b,d c,d a,c d,e Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Grafo: a,b b,d c,d a,c d,e Camino: a,b,d,e Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Grafo: a,b b,d c,d a,c d,e Ciclo: a,b,d,c Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Grafo dirigido: a,b b,d c,d a,c d,e Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Grafo con pesos: a,b,7 b,d,3 c,d,4 a,c,2 d,e, Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Problemas de Búsqueda: Son los problemas genéricos cuando F(x) puede ser vacío o contener varios elementos: Para una entrada x el problema consiste en encontrar una solución y que cumpla una relación con x cuando este exista y decir NO cuando F(x) /0. Ejemplo: dado un grafo no dirigido encontrar un circuito hamiltoniano. Problemas de Decisión: Son aquellos en los que las soluciones son Y {SI,NO} y cada entrada x tiene una única solución. Ejemplo: dado un grafo determinar si tiene un circuito hamiltoniano. Problemas de Optimización: La solución optimiza (minimiza o maximiza) una función deﬁnida sobre un conjunto de soluciones factibles asociadas a la entrada. Ejemplo: el problema del viajante de comercio. Problemas de función: Cada entrada x tiene siembre una y sólo una solución: F(x) tiene un solo elemento. Por ejemplo, dado un número n calcular su cuadrado n2. A la solución que corresponde a la entrada x se le denota también por Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Los probemas de decisión son especialmente importantes ya que son simples y es fácil razonar sobre ellos y además cualquier otro problema tiene asociado un problema de decisión: Problemas de umbral para problemas de optimización: Los mismos datos de un problema de optimización más un umbral K y ahora se pregunta si existe una solución de valor mayor o menor que el valor K según sea un problema de máximo o mínimo. Ejemplo: dado un caso del problema del viajante de comercio y un valor K determinar si existe un circuito de coste menor o igual que K. Problemas de existencia para problemas de búsqueda: Dado un x, determinar si existe un y tal que sea una solución de x. Problemas de comprobación para problemas de función y búsqueda: Dado x y una posible solución y determinar si y es una solución de x. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Camino mínimo: Dado un grafo y dos nodos, encontrar un camino de longitud mínima entre estos nodos si este existe (problema de optimización). Búsqueda de caminos: Dado un grafo y dos nodos, encontrar un camino entre ambos nodos, en caso de que exista, decir NO en caso contrario. Existencia de Caminos: Dado un grafo y dos nodos, determinar si existe un camino entre ellos (problema de existencia). Umbral del camino mínimo: Dado un grafo, dos nodos, y un umbral K determinar si existe un camino entre estos nodos de longitud menor o igual a K (problema de umbral). Problema de comprobación: Dado un grafo, dos nodos, y un camino, determinar si es un camino que une esos dos nodos (problema de comprobación). Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Un problema computacional de decisión en el que las entradas se codiﬁcan como palabras del alfabeto A con el lenguaje de las entradas que tienen respuesta SI: L(PROBLEMA(x)) {x A : PROBLEMA(x) SI}. Es decir los casos con respuesta aﬁrmativa. Un lenguaje L sobre un alfabeto A, siempre deﬁne también un problema de decisión: dada x A determinar si x L. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Palabras de A Cuando comenzamos con un problema genérico de decisión y lo transformamos en un problema computacional mediante una codiﬁcación de las entradas, las palabras que no son una codiﬁcación correcta de un ejemplo del problema se meten en el mismo saco que los casos en los que la respuesta es NO. La identiﬁcación de las codiﬁcaciones correctas (palabras que corresponden realmente a un ejemplo del problema) se considera que no es importante desde el punto de vista computacional y no se tendrá en cuenta. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Un problema de decisión Una codiﬁcación Problema Computacional SI NO Problema Computacional SI NO Lenguaje La identiﬁcación de las codiﬁcaciones correctas (palabras que corresponden realmente a un ejemplo del problema) se considera que no es importante desde el punto de vista computacional (en todos los ejemplos el reconocimiento de una entrada correcta se puede realizar de forma eﬁciente). Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Dado un problema de decisión PROBLEMA, el problema contrario de PROBLEMA, es el problema CPROBLEMA que intercambia las salidas SI y N0 o de forma más precisa PROBLEMA(x) SI CPROBLEMA(x) NO. Problemas contrarios y lenguajes El lenguaje asociado al problema contrario de PROBLEMA es el lenguaje complementario del lenguaje del lenguaje asociado a PROBLEMA: L(CPROBLEMA) L(PROBLEMA) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Dado un problema de decisión PROBLEMA, el problema contrario de PROBLEMA, es el problema CPROBLEMA que intercambia las salidas SI y N0 o de forma más precisa PROBLEMA(x) SI CPROBLEMA(x) NO. Problemas contrarios y lenguajes El lenguaje asociado al problema contrario de PROBLEMA es el lenguaje complementario del lenguaje del lenguaje asociado a PROBLEMA: L(CPROBLEMA) L(PROBLEMA) Nota: Cuando hablamos de problemas genéricos, esto no es del todo exacto: ya que las codiﬁcaciones incorrectas estarán englobadas con el SI en el lenguaje complementario o problema contrario, pero nosotros consideraremos que esta propiedad también se aplica a los problemas genéricos sin tener esto en cuenta: en realidad no importa como se traten las codiﬁcaciones incorrectas, ya que estas son siempre fáciles de detectar. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Ejemplo: Isomorﬁsmo de subgrafos X: Datos Dos grafos G1 (V1,E1) y G2 (V2,E2) Y: SI,NO (Problema de Decisión) Relación: Respuesta SI corresponde a ¿Contiene G1 un subgrafo isomorfo a G2? Es decir, existe un subconjunto V V1 y un subconjunto de aristas E E1 tal que E V V y existe una aplicación biyectiva f : V2 V de tal manera que se veriﬁca (u,v) E2 (f (u),f (v)) E Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Supongamos un alfabeto A {a1,...,an}. Podemos establecer una correspondencia biyectiva entre las palabras sobre este alfabeto y los números naturales. Supongamos j1ij.nj1, w aik ...,ai1, entonces el número de w que denotaremos como N(w) es k siendo N(ε) 0. Ejemplo Si A {0,1,2}, N(ε) 0,N(0) 1,N(1) 2,N(2) 3,N(202) 3133 Dado un alfabeto A {a1,...,an}, Si m es un número natural, siempre se puede encontrar una cadena, que denotaremos como C(m) o como wm cuya codiﬁcación sea m. Esto se puede conseguir de la siguiente forma, Si m 0, C(m) ε Si m 0, sea i (cid:26) R(m,n) n p (cid:26) [m/n] [m/n] donde R(m,n) es el resto de la división entera de m entre n y [m/n] es la división entera de m entre n. Entonces C(m) C(p)ai. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Si tenemos dos alfabetos A y B podemos establecer una aplicación biyectiva entre las palabras de ambos alfabetos: Sea NA la aplicación que codiﬁca las palabras de A como números naturales: NA : A N. Sea CB la aplicación que transforma números naturales en palabras sobre B: CB : N B. La composición CB NA es una aplicación biyectiva de A en B (primero se calcula el código numérico de una palabra de B y entonces la palabra del alfabeto de A que corresponde a ese código. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Si tenemos dos alfabetos A y B podemos establecer una aplicación biyectiva entre las palabras de ambos alfabetos: Sea NA la aplicación que codiﬁca las palabras de A como números naturales: NA : A N. Sea CB la aplicación que transforma números naturales en palabras sobre B: CB : N B. La composición CB NA es una aplicación biyectiva de A en B (primero se calcula el código numérico de una palabra de B y entonces la palabra del alfabeto de A que corresponde a ese código. Es suﬁciente trabajar sobre un sólo alfabeto. Usualmente, lo haremos sobre el alfabeto {0,1} (para desarrollar la teoría) aunque lo haremos sobre alfabetos más amplios (ASCII) para un caso práctico. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Si A {a1,...,an} nosotros siempre vamos a considerar el siguiente orden total en sus palabras: u1 u2 si y solo si se da una de las siguientes condiciones: 1 u1 u2 u1 u2 u1 u2 y u1 precede a u2 en orden alfabético, teniendo en cuenta que a1 a2 an. Es decir si u1 ar1 ...ari al1 ...alm y s1 l1 (el primer símbolo en el que son distintas las palabras es menor en u1 que en u2. as1 ...asm y u2 ar1 ...ari Esto es equivalente a u1 u2 si y solo si N(u1) N(u2) El orden alfabético como tal no es operativo ya que no podemos establecer un ciclo inﬁnito que recorra todas las palabras: hay inﬁnitas palabras que empiezan por a1 antes de las palabras que empiezan por a2 y nunca se llegaría a ellas. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Se le puede asignar a cada MT sobre un alfabeto {0,1} una cadena y un número natural. Para ello, suponemos Los estados son {q1,...,qk}. El estado inicial es q1 y hay un único estado ﬁnal q2 (esto siempre se puede conseguir). Los símbolos de B son {a1,a2,...,am} donde a1 es 0, a2 es 1 y a3 es el símbolo blanco. Al movimiento izquierda le asignamos un 1 y al de la derecha un 2. Este número será u(M). La codiﬁcación de la MT se realiza de la siguiente forma: Cada transición δ(qi,aj) (qk,al,M) se codiﬁca como 0i10j10k10l10u(M). Todas las transiciones se van añadiendo a la codiﬁcación separadas por 11. Una vez calculada la cadena w M , podemos calcular su número N(w) con el alfabeto {0,1}, según el procedimiento que hemos visto para asignar números a palabras. Este número también se denotará como N(M). Cada número natural corresponderá a una MT, o corresponderá a una cadena sin sentido alguno. Sea T(n) la MT correspondiente al número n o Nula (que rechaza todas las palabras) si no hay MT asociada al número n. También denotaremos como T(w) la MT cuyo código es w: M w. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Para codiﬁcar una MT M y una palabra w sobre el alfabeto {0,1}, podemos codiﬁcar M como hemos visto y después añadir 111 seguido de w, dando lugar a la cadena M,w Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Vamos a deﬁnir un lenguaje Ld sobre {0,1} que no es r.e. Este lenguaje se conoce como lenguaje de diagonalización. Lenguaje de Diagonalización Sea w {0,1}, w Ld si y solo si la MT cuya codiﬁcación es w (T(w)) no acepta w. Se interpreta que si w no es un MT correcta, entonces representa una MT con un sólo estado y ninguna transición (siempre rechaza). Si w0,w1,w2,... son todas las palabras de {0,1} ordenadas, entonces Ld { M M no acepta M como entrada } Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Vamos a deﬁnir un lenguaje Ld sobre {0,1} que no es r.e. Este lenguaje se conoce como lenguaje de diagonalización. Lenguaje de Diagonalización Sea w {0,1}, w Ld si y solo si la MT cuya codiﬁcación es w (T(w)) no acepta w. Se interpreta que si w no es un MT correcta, entonces representa una MT con un sólo estado y ninguna transición (siempre rechaza). Si w0,w1,w2,... son todas las palabras de {0,1} ordenadas, entonces Ld { M M no acepta M como entrada } Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Supongamos una MT Md que acepta Ld. Dicha MT estará deﬁnida sobre el alfabeto {0,1}. Dicha máquina acepta palabras w tales que la máquina de Turing con codiﬁcación w no acepta w. Sea Md la codiﬁcación de la MT Md. Si Md Ld entonces Md acepta Md (ya que Md acepta Ld), como consecuencia y por la deﬁnición de Ld, Md 6 Ld. Si Md 6 Ld entonces Md no acepta Md (ya que Md acepta Ld) y, por la deﬁnición de Ld, Md Ld. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables A la versión problema de decisión del lenguaje de diagonalización le llamaremos Problema de Diagonalización y lo notaremos como DIAGONAL(M). Consiste en determinar si dada una máquina de Turing M, entonces M no acepta cuando se lee a ella misma. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Recordatorio: Problemas y Lenguajes Dada u, ¿es u L? Conjunto x, es tal que PROBLEMA(x) SI Aceptar Responder SI Algoritmo SI/NO Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Recordatorio: Problemas y Lenguajes Lenguaje recursivamente enumerable Problema semidecidible Existe una MT que acepta las palabras del lenguaje. Para las palabras del lenguaje la MT puede rechazar o ciclar. Existe un algoritmo que responde correctamente las entradas cuya salida es SI, para las entradas de NO el algoritmo puede decir NO o ciclar Lenguaje recursivo Problema decidible Existe una MT que acepta las palabras del lenguaje y rechaza las palabras que no son del lenguaje (nunca cicla). Existe un algoritmo que responde correctamente las entradas cuya salida es SI y aquellas cuya salida es NO (nunca cicla). Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Si L A, el complementario de L respecto a A se denotará como L. Si L es recursivo, entonces es aceptado por una MT que siempre para. Se construye M con las siguientes características: Los estados de aceptación de M se convierten en estados de rechazo de M donde no se realizan nuevas transiciones. M tiene un nuevo estado r que es de aceptación y que no tiene transiciones deﬁnidas. Para cada estado p de M que no sea de aceptación y para cada símbolo de la cinta a B para el que no haya deﬁnida una transición, se añade δ(p,a) (r,a,D). Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Sea M1 la MT que acepta L y M2 la MT que acepte L. Vamos a construir una MT M con dos cintas: en una funciona como M1 y en la otra como M2. M es una máquina que funciona como M1 y M2 a la vez (como en el autómata producto). El conjunto de estados de M es el producto Q1Q2 donde Q1 es el conjunto de estados de M1 y Q2 el de M2. En cada paso, se pasa al estado que correspone según M1 y al estado que corresponde según M2. La MT termina cuando una de las dos máquinas termina. Los estados de aceptación de M son las parejas, en las que el primer elemento es un estado de aceptación de M1. Está claro que M acepta L y siempre termina, ya que toda palabra u A está en L o en L. En el primer caso, M1 termina y en el segundo lo hace M2. Por lo tanto M siempre termina. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables El lenguaje universal Lu es el conjunto de todas v las cadenas del alfabeto {0,1} que codiﬁcan parejas (M,w) (es decir v M,w ) tales que la MT M acepta la cadena w, donde w {0,1} y el alfabeto de entrada de M es {0,1}. A la versión problema de decisión del lenguaje universal le llamaremos Problema Universal y lo notaremos como UNIVERSAL(M.w). Consiste en determinar si dada una máquina de Turing M y una entrada w, entonces M acepta w. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables La idea básica es construir una MT Mu que lea la codiﬁcación M,w simule la MT M sobre la entrada w y termine cuando termina M, aceptando si lo hace M. Esta MT se llama Máquina de Turing Universal. Está claro que si hace la simulación, aceptará cuando M acepta w. Mu contiene varias cintas: En la primera contiene la codiﬁcación de M y w En la segunda contiene lo que sería la cinta de M para la entrada w. Un símbolo ai B se representa como 0i y los distintos símbolos se separan por un 1. En la tercera cinta representa el estado de M. El estado qi se representa mediante 0i La cuarta cinta se utiliza para cálculos auxiliares Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Demostración (cont.) Inicializa la tercera cinta con 0 que corresponde con el estado inicial (suponemos que es q1). 0i10j10k10l10m donde qi es el estado en el que se encuentra, 0j1 es lo que se ve en la segunda cinta. Si no lo encuentra para. Entonces debe de ejecutar el movimiento correspondientes: 1 Cambiar el la cinta 3, el estado a 0k 2 Sustituir 0j en la cinta 2 por 0l 3 Hacer el movimiento en la cinta 2, según sea m (m 1 a la izquierda, m 2 a la derecha). 5 Si M pasa a un estado de aceptación (el estado q2), entonces Mu para y acepta. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Si M es una MT que aceptase Lu, construiríamos la siguiente MT, M: Si M lee w entonces, convierte w en w111w (como la codiﬁcación de (w,w)). Entonces pasa a funcionar como M, aceptando si M acepta. M acepta w si y solo sí, M acepta w111w. Es decir w111w 6 Lu. Esto es la MT cuya codiﬁcación es w no acepta la palabra w. Esto es equivalente a que w Ld. Hemos construido una MT que acepta Ld, en contra de lo que sabemos: Ld no es r.e. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Teorema El problema universal UNIVERSAL(M,w) no es decidible. Demostración Por reducción al absurdo: Si UNIVERSAL(M,w) fuese decidible, entonces existiría un programa PROGRAMA(M,w) que siempre termina y lo resuelve. Construyamos ahora el siguiente programa: PROGRAMAD(M) SAL PROGRAMA(M,M) Si SALNO Return SI Return NO Pero este programa tiene como entrada una MT M y responde SI cuando esta máquina no acepta su propia codiﬁcación, luego implicaría que el problema de diagonalización es decidible, lo que sabemos que no es cierto. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de lenguajes) Si L1 A y L2 B son lenguajes, el lenguaje L1 se reduce al lenguaje L2 si existe un algoritmo M (una MT) que siempre para y calcula una función f : A B tal que para toda entrada w A, w L1 f (w) L2. SI/NO Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de lenguajes) Si L1 A y L2 B son lenguajes, el lenguaje L1 se reduce al lenguaje L2 si existe un algoritmo M (una MT) que siempre para y calcula una función f : A B tal que para toda entrada w A, w L1 f (w) L2. f (w) SI/NO Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de lenguajes) Si L1 A y L2 B son lenguajes, el lenguaje L1 se reduce al lenguaje L2 si existe un algoritmo M (una MT) que siempre para y calcula una función f : A B tal que para toda entrada w A, w L1 f (w) L2. f (w) f (w) SI/NO Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de problemas) Sean PROBLEMA1 y PROBLEMA2 problemas de decisión, entonces decimos que PROBLEMA1 se reduce a PROBLEMA2 si existe un algoritmo ALG(w) que siempre para y calcula una función f (w) tal que para toda entrada w a PROBLEMA1, tenemos que PROBLEMA2 produce la misma respuesta para la entrada f (w) ALG(w). SI/NO Una reducción de PROBLEMA1 a PROBLEMA2 es una algoritmo ALG(x) de las entrandas de PROBLEMA1 a las entrandas de PROBLEMA2 de tal forma que PROBLEMA1(x) PROBLEMA2(ALG(x)) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de problemas) Sean PROBLEMA1 y PROBLEMA2 problemas de decisión, entonces decimos que PROBLEMA1 se reduce a PROBLEMA2 si existe un algoritmo ALG(w) que siempre para y calcula una función f (w) tal que para toda entrada w a PROBLEMA1, tenemos que PROBLEMA2 produce la misma respuesta para la entrada f (w) ALG(w). f (w) SI/NO Una reducción de PROBLEMA1 a PROBLEMA2 es una algoritmo ALG(x) de las entrandas de PROBLEMA1 a las entrandas de PROBLEMA2 de tal forma que PROBLEMA1(x) PROBLEMA2(ALG(x)) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de problemas) Sean PROBLEMA1 y PROBLEMA2 problemas de decisión, entonces decimos que PROBLEMA1 se reduce a PROBLEMA2 si existe un algoritmo ALG(w) que siempre para y calcula una función f (w) tal que para toda entrada w a PROBLEMA1, tenemos que PROBLEMA2 produce la misma respuesta para la entrada f (w) ALG(w). f (w) f (w) SI/NO Una reducción de PROBLEMA1 a PROBLEMA2 es una algoritmo ALG(x) de las entrandas de PROBLEMA1 a las entrandas de PROBLEMA2 de tal forma que PROBLEMA1(x) PROBLEMA2(ALG(x)) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción (en términos de problemas) Sea ALG(w) el algoritmo de la reducción de PROBLEMA1 a PROBLEMA2. Supongamos que ALG2(x) es un algoritmo que hace a PROBLEMA2 semidecidible (decidible), entonces el algoritmo: ALG1(x) w ALG(x) Return (ALG2(w)) hará al problema PROBLEMA1 semidecidible (decidible). Por lo tanto si PROBLEMA1 no es semidecidible (decidible), tampoco lo puede ser PROBLEMA2. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Deﬁnimos los siguientes lenguajes sobre el alfabeto {0,1}: Le conjunto de palabras M tales que M es una MT sobre {0,1} que no acepta ninguna palabra (L(M) /0). Lne conjunto de palabras M tales que M es una MT sobre {0,1} que acepta alguna palabra (L(M) /0)(L(M) 6 /0). VACIO(M) es la versión de problema de Le: dada una MT M, determinar si acepta el lenguaje vacío. C-VACIO(M) es la versión de problema de Lne: dada una MT M, determinar si acepta un lenguaje distinto del vacío. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Semidecidivilidad de C-VACIO(M) Hay una MT no determinista M que acepta Lne: C-VACIO(M) es semidecidible. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Lne no es recursivo (C-VACIO(M) no es decidible) Vamos a demostrarlo usando los problemas asociados. Vamos a reducir UNIVER- SAL(M,w) and C-VACIO(M). Eso consiste en un algoritmo ALG(M,w) que calcula una MT M de tal manera que UNIVERSAL(M,w) tenga la misma solución que C-VACIO(M). Este funciona de la siguiente forma: Supongamos una entrada (M,w) vamos a construir una MT M que funciona de la siguiente forma. M ignora su entrada x y coloca en la cinta de entrada w. Si la longitud de w es n, esto se puede hacer con n estados. Cada estado qi escribe el símbolo i de (M,w) y se mueve a la derecha. Después pasaría a un nuevo estado en el que borra lo que quede de x. M se mueve a la izquierda hasta el primer símbolo de w. M pasa al estado inicial de M con w y funciona como M para w. La salida de M es la misma que la de M para w. Está claro que M acepta w si y solo si M acepta alguna palabra. De hecho L(M) A si M acepta w y L(M) /0 si M no acepta w. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Dada una entrada (M,w) la reducción construye la siguiente MT: SI/NO Teorema Le no es r.e. (si lo fuese, entonces Lne sería recursivo) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Propiedad lenguaje r.e. Propiedad de los lenguajes de las MTs Una propiedad de los lenguajes r.e. se identiﬁca con el problema de saber si el lenguaje de una MT veriﬁca esa propiedad. Es una problema de decisión del tipo: Dada una MT M, ¿veriﬁca el lenguaje L(M) la propiedad P? Ejemplo Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Llamemos NOTRIVIAL(M) a dicha propiedad no trivial y supongamos una propiedad no trivial y supongamos que el lenguaje vacío aceptado por la MT Me no veriﬁca la propiedad que otro lenguaje L aceptado por la MT ML si veriﬁca la propiedad. Vamos a reducir el problema UNIVERSAL(M,w) a esta propiedad. Supongamos (M,w) una MT y su entrada construimos M de la siguiente forma (se supone que tiene una entrada x en la primera cinta): M tiene dos cintas. En la segunda coloca a w y empieza trabajando sobre esta cinta con las mismas transiciones de M. Si termina y no acepta, entonces M no acepta. Si M termina y acepta con w, entonces empieza a funcionar como ML sobre la entrada x en la primera cinta y tiene la misma salida que ML. Está claro que si M acepta w, entonces el lenguaje de M es L y veriﬁca la propiedad. Si M no acepta w, entonces el lenguaje de M es vacío y no veriﬁca la propiedad. Con esto se acaba la reducción y la propiedad no es decidible. Si el lenguaje vacío acepta la propiedad se haría la misma transformación con la pro- piedad complementaria, demostrando que no es decidible y, por lo tanto, la propiedad original tampoco lo es. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Dada una entrada para el problema universal (M,w) se construye la siguiente MT M M SI/NO Está claro UNIVERSAL(M,w) tiene respuesta SI, entonces M acepta w, entonces M acepta L y la respuesta de NOTRIVIAL(M) es también SI. Si UNIVERSAL(M,w) tiene respuesta NO, entonces M no acepta w, y esta máquina M acepta /0 y la respuesta de NOTRIVIAL(M) es también NO. Como UNIVERSAL(M,w) no es decidible, NOTRIVIAL(M) tampoco lo es. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables El Problema de las Correspondencias de Post (POST(A1,A2)) Tenemos un alfabeto de referencia A, y dos listas con la misma longitud B1 w1,...,wk, B2 u1,...,uk de palabras sobre A. El problema es determinar si existe una secuencia no vacía de enteros i1,...,im tales que wi1 ...wim ui1 ...uim. Podemos pensar en cada pareja (wi,ui) como un bloque de construcción: La especiﬁcación del problema nos da un conjunto de bloques disponibles. Por ejemplo: Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables El Problema de las Correspondencias de Post (POST(A1,A2)) Tenemos un alfabeto de referencia A, y dos listas con la misma longitud B1 w1,...,wk, B2 u1,...,uk de palabras sobre A. El problema es determinar si existe una secuencia no vacía de enteros i1,...,im tales que wi1 ...wim ui1 ...uim. Podemos pensar en cada pareja (wi,ui) como un bloque de construcción: La especiﬁcación del problema nos da un conjunto de bloques disponibles. Por ejemplo: En este caso, la respuesta es aﬁrmativa. Secuencia: 1,3,1,1,3,2, Si visitáis la página web:  podéis practicar con numerosos ejemplos de este puzzle. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables El Problema de las Correspondencias de Post Modiﬁcado (POSTM(A1,A2)) PCP Modiﬁcado Tenemos un alfabeto de referencia A, y dos listas con la misma longitud B1 w1,...,wk, B2 u1,...,uk de palabras sobre A tales que ui,wj 6 ε y un entero i. El problema es determinar si existe una secuencia no vacía de enteros i1,...,im tales que i1 i y wi1 ...wim ui1 ...uim. La única diferencia es que ahora nos dicen el bloque por el que necesariamente hay que comenzar y que las palabras son no vacías. Vamos a suponer siempre que el bloque por el que hay que empezar es el primero de la lista de los bloques (sólo hay que reordenar los bloques para que el que nos indican como bloque por el que hay que empezar aparezca primero. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Supongamos el ejemplo: Como problema de las correspondencias de Post, tiene solución: 3,2,3,1 (respuesta aﬁrmativa) Efectivamente sale: Con lo que se lee bbaabbbaa en la parte superior e inferior. Sin embargo, como PCP modiﬁcado no tiene solución (respuesta negativa) ya que en ese caso, una solución tiene que empezar por el primer bloque, y así la palabra superior empieza por baa y la inferior por bb y ya, pongamos lo que pongamos después, las palabras resultantes no pueden ser iguales. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Un algoritmo no-determinista que acepta los casos positivos es: Secuencia [] Fin Falso Mientras No Fin Elige i entre 1 y k Añade i a Secuencia Elige Fin Verdadero o Fin False Comprueba que eligiendo los bloques en el orden Secuencia es una solución del PCP Si es solución responde SI, en caso contrario responde NO Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Si A tiene dos símbolos, podemos codiﬁcar palabras de cualquier alfabeto, de manera que sea un homomorﬁsmo y tal que el problema codiﬁcado tenga solución si y solo si el original la tiene. Por ejemplo, si el alfabeto es A {a,b,c}, podemos codiﬁcar a 00, b 01, c 11. Así una ﬁcha se codiﬁcaría símbolo a símbolo: Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Vamos a reducir el lenguaje universal UNIVERSAL(M,w) a este problema. Vamos a suponer una MT M y una palabra w. La pregunta es si w L(M). Vamos a construir un problema de correspondencias de Post modiﬁcado con la misma solución. El alfabeto que vamos a considerar para el alfabeto del problema de las correspondencias es el alfabeto de la MT, más el conjunto de estados, más un separador que no esté en los conjuntos anteriores Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Demostración (Cont.) Si w a1...an, introducimos el bloque q0a1...an Por cada transición δ(q,a) (q,b,D), introducimos el bloque qa bq Por cada transición δ(q,a) (q,b,I), introducimos el bloque cqa qcb Para cada q F (estado ﬁnal), añade los bloques q Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Demostración (Cont.) Cada conﬁguración (q,u,v) se representa por la cadena uqv y las distintas conﬁguraciones se separan por . En la parte de abajo se lleva una conﬁguración de ventaja respecto a la parte de arriba. Eso ocurre para cada cálculo, pero cuando se llega a un estado de aceptación, entonces la parte de abajo empieza a disminuir símbolo a símbolo paso a paso y copiándose arriba, hasta que quede abajo ...q y arriba ...qa ó ...aq donde q es el estado ﬁnal. Entonces podemos completar con el último bloque q Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Consideremos la MT M ({q0,q1,q2,q3,q4},{0,1},{0,1,X,Y,},δ,q0,,{q4}) donde las transiciones no nulas son las siguientes: δ(q0,0) (q1,X,D) δ(q0,Y) (q3,Y,D) δ(q1,1) (q2,Y,I) δ(q1,0) (q1,0,D) δ(q1,Y) (q1,Y,D) δ(q2,0) (q2,0,I) δ(q2,X) (q0,X,D) δ(q2,Y) (q2,Y,I) δ(q3,Y) (q3,Y,D) δ(q3,) (q4,,D) y la palabra de entrada 000111 Una solución del PCP modiﬁcado, tiene que empezar con la ﬁcha: q0000111 Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Ejemplo (Cont.) q0000111 Cómo δ(q0,0) (q1,X,D), tenemos la ﬁcha de proceder en una posible solución es: q0000111 Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Ejemplo (Cont.) De esta forma, al ﬁnal del cálculo de la MT llegaremos a una situación en la que tendremos lo siguiente en las partes superior e inferior de una solución (representamos como una única ﬁcha la solución parcial): u uXXXYYYq4 u uXXXYYYq4 q4 q4 Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Ejemplo (Cont.) Si vamos repitiendo este proceso, cada vez podemos disminuir lo que hay en la parte inferior en un símbolo de la cinta, hasta que lleguemos a una situación en la que tenemos: w w q4 q4 por ser q4 ﬁnal, obteniendo una solución: w w q4 q4 Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Se reduce el problema de las correspondencias de Post modiﬁcado al problema de las correspondencias de Post PCPM(A1,A2) PCP(B1,B2) , , que el primero necesariamente es el bloque 1, como un ejemplo del problema PCPM(A1,A2) Construimos el siguiente problema de Post, PCP(B1,B2), con dos símbolos nuevos: (cid:7),(cid:4) y con los bloques: (cid:7)u2 (cid:7)u1 (cid:7)v1(cid:7) , v2(cid:7) , , Donde, si u a1a2...an, se entiende que (cid:7)u1 v1(cid:7) , (cid:7)un vn(cid:7) , (cid:7)(cid:4) (cid:4) (cid:7)u (cid:7)a1(cid:7)a2...(cid:7)an, u(cid:7) a1(cid:7)a2...(cid:7)an(cid:7), (cid:7)u(cid:7) (cid:7)a1(cid:7)a2...(cid:7)an(cid:7) Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables PCPM(B1,B2): , , PCP(B1,B2): (cid:7)u1 v1(cid:7) , (cid:7)un vn(cid:7) , Como se puede ver, las soluciones a ambos problemas son equivalentes. Si el modiﬁcado tiene solución, entonces los bloques asociados con los dos símbolos nuevos son una solución del PCP ﬁnalizados por el bloque (cid:7)(cid:4) (cid:4) . (cid:7)u1 (cid:7)v1(cid:7) , (cid:7)u2 v2(cid:7) , , (cid:7)(cid:4) (cid:4) (cid:7)u1 (cid:7)v1(cid:7) ya que es la única que comienza en ambas partes por el (cid:7)(cid:4) (cid:4) . Si a todos los bloques distintos del último les quitamos los dos símbolos especiales obtenemos una solución del PCP modiﬁcado que empieza por la ﬁcha 1, mismo símbolo (cid:7) y además terminar por Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Saber si L(G1)L(G2) /0. Determinar si L(G) T, donde T es el conjunto de símbolos terminales. Comprobar si L(G1) L(G2). Determinar si L(G1) L(G2). Determinar si L(G1) R. Comprobar si L(G) es regular. Determinar si G es ambigua. Conocer si L(G) es inherentemente ambiguo. Comprobar si L(G) es determinista. Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables Reducción: ambigüedad Teorema Saber si una gramática independiente del contexto es ambigua (AMBIGUA(G)) es indecidible. , , Sea B A{b1,...,bk} donde bi 6 A y construimos la siguiente gramática: S CD C uiCbiuibi, D viDbivibi, La solución al problema de las correspondencias de Post es equivalente a que la gramática sea ambigua. i 1,...,k i 1,...,k Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables , , Sea B A{b1,...,bk} donde bi 6 A y construimos la siguiente gramática: S CD, C uiCbiuibi, Se basa en lo siguiente: i 1,...,k, D viDbivibi, i 1,...,k, Las palabras generadas por la gramática son las generadas a partir de C más las generadas a partir de D Las palabras generadas a partir de C son de la forma ui1 ...uilbil ...bi1, donde ij {1,...,k}. Sólo hay una forma de generar una de estas palabras a partir de C. Las palabras generadas a partir de D son de la forma vi1 ...vilbil ...bi1, donde ij {1,...,k}. Sólo hay una forma de generar una de estas palabras a partir de D. La gramática es ambigua cuando una misma palabra u es generada a partir de C y a partir de D, es decir cuando u ui1 ...uinbil ...bin vi1 ...vi n . n Esto solo ocurre si n n e ij i j,j. Es decir cuando existen (i1,...,in) tal que ui1 ...uin vi1 ...vin, es decir cuando el PCP tiene solución. bi 1 ...bi Tema 1: Máquinas de Turing. Funciones y Lenguajes Calculables