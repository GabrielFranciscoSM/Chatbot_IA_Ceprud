Modelos Avanzados de Computación: Tema 3: Clases de Complejidad smcdecsai.ugr.es Departamento de Ciencias de la Computación e IA ETSI Informática Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Un problema sencillo: el ﬂujo máximo. Un problema difícil: mínimo número de colores. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Nuesto objetivo último: comprender mejor (de manera profunda) la naturaleza de los problemas y los algoritmos que los resuelven. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Recursos que consume (espacio, tiempo, etc.) Diﬁcultad absoluta o relativa. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Recursos que consume (espacio, tiempo, etc.) Diﬁcultad absoluta o relativa. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Abstracción de ejemplos: complejidad en función del tamaño de la entrada y en el peor de los casos. Abstracción del Modelo: Máquina de Turing. Inicialmente se trabaja con lenguajes (se abstrae la codiﬁcación). Recursos: Tiempo, espacio Algoritmos: El mejor algoritmo Clases de complejidad: clases muy amplias. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Crecimiento Polinómico vs Crecimiento Exponencial n n n n n n 2 1,3 Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Si tengo un número x, ¿cuantos caracteres necesito para escribir x? Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Si tengo un número x, ¿cuantos caracteres necesito para escribir x? Ya sea en binario, decimal, o con la codiﬁcación del tema anterior, si el número es x el número de caracteres que necesito es de orden n log(x). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Si tengo un número x, ¿cuantos caracteres necesito para escribir x? Ya sea en binario, decimal, o con la codiﬁcación del tema anterior, si el número es x el número de caracteres que necesito es de orden n log(x). Si quiero escribir un número en decimal, por ejemplo 1365, necesito 4 caracteres (dígitos). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Si tengo un número x, ¿cuantos caracteres necesito para escribir x? Ya sea en binario, decimal, o con la codiﬁcación del tema anterior, si el número es x el número de caracteres que necesito es de orden n log(x). Si quiero escribir un número en decimal, por ejemplo 1365, necesito 4 caracteres (dígitos). La complejidad de un problema en el que aparezca este número 1365 no hay que medirla en función de su valor (1365), sino en función del número de caracteres necesario para escribirlo (4) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Si tengo un número x, ¿cuantos caracteres necesito para escribir x? Ya sea en binario, decimal, o con la codiﬁcación del tema anterior, si el número es x el número de caracteres que necesito es de orden n log(x). Si quiero escribir un número en decimal, por ejemplo 1365, necesito 4 caracteres (dígitos). La complejidad de un problema en el que aparezca este número 1365 no hay que medirla en función de su valor (1365), sino en función del número de caracteres necesario para escribirlo (4) Esta medida se puede aplicar a cualquier problema, sea numérico, de grafos, de conjuntos, o de cualquier tipo. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Si tengo un número x, ¿cuantos caracteres necesito para escribir x? Ya sea en binario, decimal, o con la codiﬁcación del tema anterior, si el número es x el número de caracteres que necesito es de orden n log(x). Si quiero escribir un número en decimal, por ejemplo 1365, necesito 4 caracteres (dígitos). La complejidad de un problema en el que aparezca este número 1365 no hay que medirla en función de su valor (1365), sino en función del número de caracteres necesario para escribirlo (4) Esta medida se puede aplicar a cualquier problema, sea numérico, de grafos, de conjuntos, o de cualquier tipo. Si n es la longitud del número en binario, entonces su valor x es de orden 2n (si es en decimal, entonces cambia la base por 10). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El número de divisiones es O(x), pero esa no es una medida correcta de la complejidad. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El número de divisiones es O(x), pero esa no es una medida correcta de la complejidad. Hay que tener en cuenta que la representación en binario de un número x ocupa del orden de n log(x) caracteres. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El número de divisiones es O(x), pero esa no es una medida correcta de la complejidad. Hay que tener en cuenta que la representación en binario de un número x ocupa del orden de n log(x) caracteres. Un número y menor que x ocupa también del orden de n casillas. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El número de divisiones es O(x), pero esa no es una medida correcta de la complejidad. Hay que tener en cuenta que la representación en binario de un número x ocupa del orden de n log(x) caracteres. Un número y menor que x ocupa también del orden de n casillas. Una división de un número de longitud n por otro de longitud n se hace con un orden O(n2). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El número de divisiones es O(x), pero esa no es una medida correcta de la complejidad. Hay que tener en cuenta que la representación en binario de un número x ocupa del orden de n log(x) caracteres. Un número y menor que x ocupa también del orden de n casillas. Una división de un número de longitud n por otro de longitud n se hace con un orden O(n2). Como el número n log(x), entonces x es de orden 2n, y el número de divisiones es de orden O(2n). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El número de divisiones es O(x), pero esa no es una medida correcta de la complejidad. Hay que tener en cuenta que la representación en binario de un número x ocupa del orden de n log(x) caracteres. Un número y menor que x ocupa también del orden de n casillas. Una división de un número de longitud n por otro de longitud n se hace con un orden O(n2). Como el número n log(x), entonces x es de orden 2n, y el número de divisiones es de orden O(2n). Multiplicando una división por el número de divisiones, nos sale O(n22n), que es una complejidad exponencial. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad G. Lamé (1884).-Número de divisiones para el máximo común divisor de dos números. Años 50 y 60.- Algoritmos Polinómicos Algoritmos Buenos J. Von Neumann, M.D. Rubin, J. Edmons Hartamis, Stearns (1965).-Análisis sistemático de medidas de complejidad especíﬁcas. Inclusión de las clases de complejidad. M. Blum (1967).-Axiomas para una medida de complejidad. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Cook (1971) The Complexity of Proving Procedures - Lavine .- Karp (1972).-Dió una amplia lista de problemas NP-completos. Meyer(1970) Stockmeyer (1976).- Deﬁnieron la jerarquían polinómica, muy útil para clasiﬁcar problemas difíciles. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Baker, Hill and Solovay (1975).- Resultados sobre complejidad relativos a oráculos. Berman y Hartmanis (1977) propusieron la conjetura del isomorﬁsmo de los problemas NP-completos. Solovay y Strassen (1977).- Consideraron algoritmos probabilistas. Valiant (1979).- Deﬁnió la clase P de las funciones que cuentan el número de soluciones. Yao (1979).- Propuso estudiar la complejidad de la comunicación (problemas distribuidos). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Babai (1985).- Sistemas interactivos de demostración. Papadimitriou y Yannakakis (1988).- Deﬁnieron clases de complejidad para la resolución aproximada de problemas. Bernstein y Vazirani (1997).- Complejidad de la computación cuántica. Los problemas matemáticos del milenio: P frente a NP  Agrawal, Kayal y Saxena (2002).- Han demostrado que la primalidad está en P. Reingold (2005).- Ha demostrado que la conectividad en grafos no dirigidos se puede resolver en espacio logarítmico. Hartmanis (31 de diciembre de 1962).- Este ha sido un buen año, En realidad están siendo unos buenos casi 60 años de complejidad computacional. El zoo de la complejidad:  ¡545 clases en abril de 2022! y subiendo. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Tenemos un grafo dirigido en el que los arcos están etiquetados por su capacidad. Hay un origen (s) y un destino (t). Un ﬂujo es una asignación de valor a cada arco que no supere su capacidad y de forma que la suma de lo que entra a cada nodo intermedio es igual a la suma de lo que sale. El valor de un ﬂujo es la suma de lo que sale del origen (que es igual a la suma de lo que llega al destino). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Partimos del problema (V,E,s,t,c) donde V es el conjunto de vértices, E el conjunto de aristas, s el nodo inicial, t el nodo ﬁnal y c es una función que asigna a cada pareja de nodos (x,y) su capacidad c(x,y). Un ﬂujo se representará por una función f 1. Se comienza con un ﬂujo cualquiera, por ejemplo el ﬂujo cero: f (x,y) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad 2. Se calcula el grafo diferencia (v,E,s,t,c) donde E E {(x,y) : f (x,y) c(x,y)}{(x,y) : f (y,x) 0} c(x,y) c(x,y)f (x,y), c(x,y) f (y,x), si (x,y) E si (x,y) 6 E Modelos Avanzados de Computación: Tema 3: Clases de Complejidad 3. Se calcula un camino de s a t en el nuevo grafo. Se le asigna un ﬂujo al nuevo camino que es valor mínimo de c en todas las aristas que lo componen. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad 4. Se añade el ﬂujo del camino al ﬂujo original. Si una arista está en el camino en sentido inverso, entonces el valor de esta arista se resta: Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Flujo Inicial Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Flujo Inicial Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Flujo Inicial Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Flujo Inicial Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (cont.) Flujo Inicial en la solución óptima: Solución Óptima: Flujo Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Flujo Máximo: Un ejemplo con problemas Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Flujo Máximo: Un ejemplo con problemas Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Flujo Máximo: Un ejemplo con problemas Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Flujo Máximo: Un ejemplo con problemas Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Flujo Máximo: Un ejemplo con problemas Así el ﬂujo se va siempre mejorando, pero de una manera muy lenta: una unidad cada vez. Si el número C es muy grande, esto da a muchas iteraciones: la complejidad es exponencial en función del número de dígitos de C. Afortunadamente existe una forma de elegir los caminos que garantiza que este crecimiento tan lento no ocurre y que la complejidad es realmente polinómica: basta con elegir en cada caso el camino más corto entre el origen y el destino. En ese caso, se puede demostrar que el número máximo de iteraciones en O(m3) donde m es el número de nodos. La complejidad total es de orden O(n5) donde n es la longitud de la entrada. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Problema de colorear un grafo (COLOR) Dado un grafo (G,V) y un número entero K K Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Problema de colorear un grafo (COLOR) Dado un grafo (G,V) y un número entero K K Modelos Avanzados de Computación: Tema 3: Clases de Complejidad En el problema de colorear grafos nadie conoce nada que se puede calcular en el grafo en tiempo polinómico y que evite la fuerza bruta: la búsqueda en el espacio de todas las opciones. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Hay otros problemas cuya resolución se puede reducir a la resolución del ﬂujo máximo (FM). Este es el caso del problema de las pareja (PAR). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El problema de las parejas PAR(V1,V2,A) Tenemos dos conjuntos del mismo tamaño V1 y V2 y un subconjunto A V1V2 (representa las compatibilidades de elementos de V1 con elementos de V2. El problema consiste en decidir si existe un subconjunto A A tal que cada elemento de v1 V1 aparece en uno y sólo en uno de los pares (v1,y) A y cada elemento de v2 V2 aparece en uno y sólo en uno de los pares (x,v2) A. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Para cada ejemplo de las parejas PAR(V1,V2,A) podemos construir un problema del ﬂujo máximo equivalente FM(G,c,s,t): Modelos Avanzados de Computación: Tema 3: Clases de Complejidad ¿FM 4? Si m es el número de elementos en V1 y V2, la pregunta equivalente al problema de las parejas es: ¿Existe un ﬂujo máximo de tamaño mayor o igual a m? Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Supongamos que FM(G,c,s,t,m) es una función que resuelve el problema del ﬂujo máximo en su versión decisión, es decir responde a la pregunta: ¿Existe un ﬂujo de valor mayor o igual a m? Supongamos que REDUCE(V1,V2,A) es el algoritmo que implementa la reducción, es decir calcula (G,c,s,t,m) REDUCE(V1,V2,A). Entonces podemos hacer un algoritmo para resolver el problema de las parejas: Calcula (G,c,s,t,m) REDUCE(V1,V2) Return FM(G,c,s,t,m) Con eso podemos usar un algoritmo del FM para resolver PAR, pero de forma más importante, como REDUCE es rápido, nos compara la diﬁcultad de FM y PAR: FM es más difícil o igual que PAR, ya que cualquier algoritmo de FM se puede usar para PAR. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Una Máquina de Turing (u otro dispositivo de cálculo) es de complejidad f (n) si y solo si para toda entrada x A de longitud x n, la máquina acepta esta entrada o la rechaza consumiento menos de f (n) unidades. Complejidad de un Lenguaje o Problema de Decisión Un lenguaje se dice de complejidad f (n) si existe una Máquina de Turing que acepta el lenguaje y tiene complejidad f (n). Unidades pasos de cálculo complejidad en tiempo Unidades casillas de la cinta complejidad en espacio Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Se dice que una medida g(n) es de orden O(f (n)) si existe n0 y c 0 tal que n n0, g(n) c.f (n). Teorema Si L es aceptado en tiempo t(n) por una Máquina de Turing con k cintas, entonces m 0 existe una Máquina de Turing con k 1 cintas que acepta el mismo lenguaje en tiempo 1 2mt(n)n Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Vamos a ver cómo se reduce el tiempo a la mitad (aplicándolo varias veces se puede obtener el resultado deseado Si M es la máquina que acepta con alfabeto A, construimos una máquina de Turing M en la que hay un símbolo nuevo w por cada 3 símbolos abc de A. La Máquina es tal que codiﬁca la cinta de entrada en otra cinta de la nueva máquina de forma que la casilla i de la nueva cinta va a representar las casillas 2i 1,2i,2i 1 de la cinta de entrada de M. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El programa para M se escribe, simulando para w lo que haría M para los símbolos abc hasta que sale de estos símbolos (o cicla en ellos). Esto siempre se puede calcular ya que son sólo 3 casillas. Esto conlleva resumir, al menos, dos pasos, por cada paso de la original. Para llevar cuenta de los símbolos escritos en las casillas comunes a dos celdas consecutivas de M se supone que ese símbolo se guarda en memoria (añadiendo estados). Con esto, cada dos pasos se hacen en 1 y se dividen los pasos por la mitad (hace falta n para cambiar la entrada y codiﬁcarla en el nuevo alfabeto). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El programa para M se escribe, simulando para w lo que haría M para los símbolos abc hasta que sale de estos símbolos (o cicla en ellos). Esto siempre se puede calcular ya que son sólo 3 casillas. Esto conlleva resumir, al menos, dos pasos, por cada paso de la original. Para llevar cuenta de los símbolos escritos en las casillas comunes a dos celdas consecutivas de M se supone que ese símbolo se guarda en memoria (añadiendo estados). Con esto, cada dos pasos se hacen en 1 y se dividen los pasos por la mitad (hace falta n para cambiar la entrada y codiﬁcarla en el nuevo alfabeto). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Los números se pueden codiﬁcar en cualquier base menos unario (es muy poco eﬁciente y necesita mucha longitud). En teoría supondremos binario, pero en la práctica usaremos decimal. Podemos suponer que cada objeto se codiﬁca con un nombre en un cierto alfabeto, por ejemplo {a,b}. Si tenemos m objetos, ¿cual será lo longitud del nombre de un objeto? Con palabras de longitud k tenemos para darle nombre a m 2k objetos (hay 2k palabras distintas de longitud k). Luego, si el número de objetos es m 2k, la longitud del nombre k es del orden de log(m) donde m es el número de objetos. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Para representar un grafo podemos usar distintos procedimientos: a) Listas los vértices y las aristas b) Dar una lista de vecinos para cada c) Dar una matriz de adyacencia del Mét. a) b) c) donde a el número de aristas está acotado por v2 Representación v[1]v[2]v[3]v[4](v[1]v[2])(v[2]v[3]) (v[2])(v[1]v[3])(v[2])() 0100/1010/0010/0000 Cota Inf. 4v 10a 2v 8a v2 v Cota Superior 4v 10a(v 2a)log10v 2v 8a2alog10v v2 v Modelos Avanzados de Computación: Tema 3: Clases de Complejidad En la complejidad de problemas sobre grafos, si lo que estamos interesados es en saber si es polinómica, da igual la representación que usemos y si la medimos en función del número de vértices. Como la longitud de la entrada n veriﬁca que v n v3, una función es de orden polinómico como función de n si y solo si lo es en función de v. Si es de orden O(nk), entonces será a lo más O(v3k). Si es de orden O(vk), entonces será a lo más O(nk). También ocurre lo mismo si queremos saber si la complejidad es de orden logarítmico O(log(n)): es independiente de la representación o si lo medimos como una función del número de vértices: el exponente en un logaritmo se transforma en una constante. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad En general para medir el número de unidades que se consumen se siguen las siguiente reglas: Se cuentan las casillas que se usan (se escribe o se pasa sobre ellas). Un algoritmo (determinista o no determinista) que tenga una determinada complejidad en espacio podría ciclar en algunas entradas, pueden existir cálculos que nunca acaben, pero siempre se puede transformar el algoritmo en uno que no cicle. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad En la práctica, en algunas ocasiones, vamos a tener un algoritmo en lugar de una MT. En ese caso podemos seguir las siguientes reglas: Se cuenta el espacio total que necesitemos para ejecutar el algoritmo, teniendo en cuenta que el nombre de un elemento de un conjunto con N objetos ocupa log(N). Si la entrada está en una estructura de datos que nunca se modiﬁca (sólo tiene los datos originales de entrada) entonces el espacio de esa estructura de datos no se cuenta. Si la salida la vamos escribiendo en un dispositivo del que nunca leemos tampoco se cuenta (puede ser que la pongamos en una estructura de datos que nunca leemos). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Reconocer palíndromos en espacio O(log(n)) Se hace con una Máquina de Turing con las siguiente estructura de cintas: 3 2 1 1 (cid:3) (cid:3) Posición que se está comprobando (binario) N2 0 1 1 (cid:3) (cid:3) (cid:3) Contador en binario para encontrar posiciones N3 1 (cid:3) Entrada Ponemos 1 en la segunda cinta (N2), Ponemos 1 en la tercera cinta (N3) - Nos ponemos al principio de la primera cinta. - Repetir: Repetir: Incrementar N3 en 1, mover a la derecha en la primera , hasta N2 N3 - Copiar el símbolo de la primera cinta en memoria - Si el símbolo en memoria es blanco Aceptar - en otro caso Poner 1 en la tercera cinta (N3 1), ir al ﬁnal de la primera cinta - Repetir: Incrementar N3 en 1, mover izquierda en la primera, hasta N2 N3 - Si símbolo en primera cinta es distinto al de memoria Rechazar - Incrementar N2 en Los números N2 y N3 necesitan log(n) casillas donde n es la longitud del número en la cinta 1. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Tenemos un grafo dirigido G y dos nodos v1 y v2. ¿Existe un camino entre estos dos nodos? Problema CAMINO(G,v1,v2) Por ejemplo la MT con tres cintas que tiene como entrada una cinta con las aristas (v,v) del grafo, y después v1 y v2 con un separados y que funciona de la siguiente forma: Colocamos v1 en la segunda y tercera cinta - Repetir hasta que la segunda cinta esté vacía: Cogemos el último elemento de la segunda cinta v - Buscamos todos los pares (v,v) en la primera cinta - Si v v2 Aceptar - Si v no está en la tercera cinta, se añade a la segunda y la tercera cinta - Se borra v de la segunda cinta Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Supongamos n el tamaño de la entrada en la primera cinta. Las cintas 2 y 3 siempre son más cortas que la entrada, luego es de O(n) en espacio. El número de pasos sobre las tres cintas es: La cinta 1 se recorre un número de veces menor o igual al número de vértices v que a su vez es menor o igual a n y como su tamaño es n, el número de pasos es de orden O(n2). En la cinta 2 cada nodo se recorre varias veces: para escribirlo, buscarlo en la primera cinta y borrarlo. Buscarlo en la entrada, a lo más una vez por arista. El número de aristas es menor o igual a n, y recorrer todos los nodos una vez es, a lo más n, luego la complejidad total es de orden O(n2). La cinta 3, hay que recorrerla cada vez que analizamos un nodo v y encontramos la arista (v,v). Como cada nodo se analiza solo una vez, entonces a lo más se recorre una vez por arista. Como el número de aristas es O(n) y el tamaño de la cinta es O(n), obtenemos O(n2) en total. En total, la complejidad en tiempo es O(n2) y en espacio O(n) También se puede hacer en espacio O(v) y en tiempo O(v3), donde v es el número de vértices (por ejemplo codiﬁcando como matriz 0-1). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad CAMINO: Espacio Determinista Teorema de Savitch: Existencia de Caminos La complejidad en espacio de existencia de caminos en grafos dirigidos es del orden O(log2(v)), donde v es el número de nodos del grafo y, por tanto, también en función del tamaño de la entrada n. La demostración se basa en una resolución ordenada del problema CAMINO(x,y,i): Existencia de un camino de longitud 2i, y la relación CAMINO(x,y,i) z,CAMINO(x,z,i 1) y CAMINO(z,y,i 1) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad CAMINO: Espacio Determinista Como si ejecutásemos el siguiente algoritmo recursivo al que hay que llamar con N log(v): CAMINO(x,y,N) - Si xy Return TRUE - Si N Para cada nodo z: Si CAMINO(x,z,N-1) Si CAMINO(z,y,N-1) - Return TRUE Modelos Avanzados de Computación: Tema 3: Clases de Complejidad CAMINO: Espacio Determinista CAMINO(x,y,3) Si los nodos son iguales, devuelve TRUE - Si N 0 comprueba en el grafo si existe un enlace - Haz primera llamada con el primer nodo - Si recibe FALSE del nivel anterior, prueba siguiente nodo - Si es el último devuelve FALSE - Si recibe TRUE de la primera: realiza segunda mismo nodo - Si recibe TRUE de la segunda, devuelve TRUE CAMINO(x,v1,2) La MT va colocando las tripletas necesarias para resolver el pro- blema de forma recursiva en una cinta separadas por un 0 ó un 1 si es la primera llamada o la segunda llamada. En cada llamada recursiva sólo hay que colocar una tripleta. Cada tripleta incluyendo el bit de primera o segunda llamada es de longitud O(log(v)) y el número de tripletas es de orden O(log(v)): TOTAL O(log2(v)) en espacio. CAMINO(x,v1,1) CAMINO(x,v1,0) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad CAMINO: Espacio Determinista CAMINO(x,y,3) Si los nodos son iguales, devuelve TRUE - Si N 0 comprueba en el grafo si existe un enlace - Haz primera llamada con el primer nodo - Si recibe FALSE del nivel anterior, prueba siguiente nodo - Si es el último devuelve FALSE - Si recibe TRUE de la primera: realiza segunda mismo nodo - Si recibe TRUE de la segunda, devuelve TRUE CAMINO(x,v1,2) La MT va colocando las tripletas necesarias para resolver el pro- blema de forma recursiva en una cinta separadas por un 0 ó un 1 si es la primera llamada o la segunda llamada. En cada llamada recursiva sólo hay que colocar una tripleta. Cada tripleta incluyendo el bit de primera o segunda llamada es de longitud O(log(v)) y el número de tripletas es de orden O(log(v)): TOTAL O(log2(v)) en espacio. CAMINO(x,v1,1) CAMINO(x,v2,0) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad CAMINO: Espacio Determinista CAMINO(x,y,3) Si los nodos son iguales, devuelve TRUE - Si N 0 comprueba en el grafo si existe un enlace - Haz primera llamada con el primer nodo - Si recibe FALSE del nivel anterior, prueba siguiente nodo - Si es el último devuelve FALSE - Si recibe TRUE de la primera: realiza segunda mismo nodo - Si recibe TRUE de la segunda, devuelve TRUE CAMINO(x,v1,2) La MT va colocando las tripletas necesarias para resolver el pro- blema de forma recursiva en una cinta separadas por un 0 ó un 1 si es la primera llamada o la segunda llamada. En cada llamada recursiva sólo hay que colocar una tripleta. Cada tripleta incluyendo el bit de primera o segunda llamada es de longitud O(log(v)) y el número de tripletas es de orden O(log(v)): TOTAL O(log2(v)) en espacio. CAMINO(x,v1,1) CAMINO(v2,v1,0) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Clases no-deterministas Una máquina de Turing no determinista tiene complejidad f (n) en tiempo (espacio) si y solo si para una entrada x de longitud n todas las posibles opciones de cálculo de la máquina terminan en f (n) pasos (terminan y no usan más de f (n) casillas). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Ejemplo (en términos de algoritmos) 1. Asignar un color posible a cada nodo: mediante una serie de pasos que asignan de forma no determinista un número mediante una serie de 0s o 1s de longitud menor o igual a la longitud de m. Para que el algoritmo resuelva el problema, si la respuesta es SI, entonces debe de existir la posibilidad de que acepte; si la respuesta es NO, necesariamente ha de rechazar. La complejidad en tiempo (no-determinista) sería proporcionar al número de arcos. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Búsqueda de Caminos en Grafos: Espacio no-determinista En espacio no-determinista el problema se resuelve en espacio O(log(v)) donde v es el número de vértices, (la misma complejidad en función de la entrada O(log(n))). Supongamos que queremos determinar si existe un camino entre el nodo xi y el nodo xj: Llamamos a Camino(xi,xj,m) con m v (el número de nodos). Si m 0 solo acepta si xi xk y rechaza si xi 6 xk. Si m 0: El algoritmo funciona escribiendo el identiﬁcador de un nodo xk conectado con xi de forma no-determinista (si no existe ninguno rechaza). a) Si xk es igual a xj, entonces para y acepta. b) Si xk es distinto de xj, vuelve a ejecutar el algoritmo con xk en el lugar de xi y m decrementado en uno. m 0: a) b) k j Llamada recursiva a Camino(xk,xj,m1) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad TIEMPO(f ) Todos los lenguajes aceptados por una máquina de Turing determinista en tiempo O(f (n)). ESPACIO(f ) Todos los lenguajes aceptados por una máquina de Turing determinista en espacio O(f (n)). NTIEMPO(f ) Todos los lenguajes aceptados por una máquina de Turing no determinista en tiempo O(f (n)). NESPACIO(f ) Todos los lenguajes aceptados por una máquina de Turing no determinista en espacio O(f (n)). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Clase polinómica (tiempo): P Sj0 TIEMPO(nj) Clase polinómica no determinista (tiempo): NP Sj0 NTIEMPO(nj) Clase polinómica (espacio): PESPACIO Sj0 ESPACIO(nj) Clase polinómica no determinista (espacio): NPESPACIO Sj0 NESPACIO(nj) Clase de espacio logarítmico determinista: L ESPACIO(log(n)) Clase de espacio logarítmico no determinista: NL NESPACIO(log(n)) Clase exponencial en tiempo: EXP Sj0(2nj ) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Todo procedimiento de cálculo físicamente realizable se puede simular por una máquina de Turing, con una sobrecarga polinómica en el número de pasos (si el mecanismo da f (n) pasos, entonces la máquina de Turing puede dar f k(n) pasos). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Tipos de Instrucciones: Mi 1 Mi Mj Mk Mi Mj Mk Mi [M1/2] Mi MMj (poner en Mi el valor conte- nido en la celda número Mj) MMi Mj (poner en la celda número Mi el valor de Mj) Goto m if Mi 0 Halt Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Entrada: m enteros en las celdas M1,...,Mm Tamaño de la Entrada: Suma del tamaño de los enteros de entrada RAM Aceptadoras: Escriben 0 en M0 si rechazan y 1 si aceptan. Si no paran rechazan RAM calculadoras de f (x): Escriben f (x) en M0 Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Máquina Simulada Máquina Turing 1 cinta: 1TM Máquina Turing k cintas: kTM O(T2(n)) Máquina RAM: RAM O(T(n)) O(T(n)logT(n)) O(T(n)logT(n)) O(T3(n)) O(T2(n)) (Del libro de Garey, Johnson. Distintos autores pueden dar distintas relaciones. Lo importante es que no cambiemos de clase cambiando de modelo.) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Teorema.- Supongamos que L es decidido por una máquina de Turing no-determinista en tiempo f (n) , entonces es decidido por una máquina de Turing determinística con 3 cintas en tiempo O(df (n)) donde d 1 es una constante que depende de la máquina no determinística inicial. Supongamos que k es el número máximo de opciones de la MT no determinista y que k 1 (en otro caso la Máquina es determinista y el resultado es trivial): Para L 0,1,2,... Vamos colocando en la tercera cinta todas las secuencias a1...aL de longitud L, donde cada símbolo se elige entre {1,...,k}. Para cada secuencia a1...aL, simulamos la MT no determinista L pasos en una segunda cinta donde en el paso i se elige la opción ai. Si para una secuencia la simulación acepta, termina y acepta Si para todas las secuencias de longitud L la simulación rechaza, entonces termina y rechaza Si no ocurre ninguna de las dos cosas, pasa al siguiente L Modelos Avanzados de Computación: Tema 3: Clases de Complejidad La simulación termina seguro cuando L f (n) o antes. La cantidad de secuencias de longitud L es kL. La cantidad total de secuencias es menor o igual a : f (n) L kL kf (n)1 1 k que es de orden kf (n). Cada simulación y cada cambio de secuencia (para pasar a la siguiente) se lleva del orden de L f (n) pasos. En total tenemos que la simulación es de orden O(f (n)kf (n)) y como f (n) es menor que kf (n), tenemos que la simulación es de orden O(kf (n).kf (n)) y teniendo en cuenta que kf (n).kf (n) k2f (n) (k2)f (n) y el resultado se obtiene para d k2. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad La clase de los lenguajes complementarios de los lenguajes en la clase C se llama CoC. Se veriﬁca que L C L CoC. El complementario de una clase determinista coincide con la propia clase: CoP P. No ocurre lo mismo con las clase no deterministas. La clase CoNP es el conjunto de problemas cuyo complementario está en NP. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Relación binaria en A A Una relación binaria R es una aplicación R : A A {0,1} Algunas veces R(x,y) 1 se escribe como R(x,y) y R(x,y) 0 como R(x,y) (interpretando 1 como Verdadero y 0 como Falso). Relación calculable polinómicamente R en AA se dice calculable polinómicamente si existe una MT M que calcula R en tiempo polinómico. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad NP Un lenguaje L A está en NP si y solo si existe una relación R en A A calculable en tiempo polinómico y un polinomio p(n) tal que L {x A : y A con y p(x),R(x,y) 1} Se dice que los lenguajes (problemas) de NP son los problemas que se pueden veriﬁcar en tiempo polinómio (de forma eﬁciente). Al algoritmo que calcula R se le llama un veriﬁcador. A y se le llama un certiﬁcado. CoNP Un lenguaje L A está en CoNP si y solo si existe una relación R en A A calculable en tiempo polinómico y un polinomio p(n) tal que L {x A : y A con y p(x),R(x,y) 1} Modelos Avanzados de Computación: Tema 3: Clases de Complejidad El problema del circuito hamiltoniano está en NP, porque se puede expresar como determinar los x (que representan grafos) para los que existe un y (que representa una sucesión de nodos) tal que todos los nodos aparecen una y una sola vez y existe un arco desde cada nodo al siguiente y del último al primero (relación R). La condición que se pide para x e y (la relación R(x,y)) se puede calcular en tiempo polinómico. La longitud del y que cumple la relación es menor que la de x, entonces la longitud de y está acotada por un polinomio de la longitud de x. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Los que se pueden expresar como: dados unos datos x comprobar si existe un objeto y (con un tamaño limitado a un polinomio del tamaño de x) tal que se cumple una condición R(x,y) 1 que es veriﬁcable en tiempo polinómico. Ejemplo Saber si un número x es compuesto: si existe 1 y x tal que la división entera de x entre y es exacta. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Los que se pueden expresar como: dados unos datos x comprobar si existe un objeto y (con un tamaño limitado a un polinomio del tamaño de x) tal que se cumple una condición R(x,y) 1 que es veriﬁcable en tiempo polinómico. Ejemplo Saber si un número x es compuesto: si existe 1 y x tal que la división entera de x entre y es exacta. C. Moore, S. Mertens (2011) The Nature of Computation. 193707721761838257287 147573952588676412927 Frank Nelson Cole, American Mathematical Society, 1903 (trabajó en ello los domingos de 3 años). El número de la derecha es 267 1 y se había conjeturado en el siglo XVII que era primo. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Los que se pueden expresar como: dados unos datos x comprobar si existe un objeto y (con un tamaño limitado a un polinomio del tamaño de x) tal que se cumple una condición R(x,y) 1 que es veriﬁcable en tiempo polinómico. Ejemplo Saber si un número x es compuesto: si existe 1 y x tal que la división entera de x entre y es exacta. C. Moore, S. Mertens (2011) The Nature of Computation. 193707721761838257287 147573952588676412927 Frank Nelson Cole, American Mathematical Society, 1903 (trabajó en ello los domingos de 3 años). El número de la derecha es 267 1 y se había conjeturado en el siglo XVII que era primo. ¿Conocéis una caracterización parecida para saber si un número es primo? Existe, pero no es sencilla. Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Existe un demostrador con capacidad ilimitada de cálculo (siempre quiere convencer de que la respuesta es positiva) Existe un veriﬁcador con capacidad polinómica de cálculo (quiere saber la verdad) El escenario es distinto si se permite aleatorizar las preguntas y un error para el veriﬁcador (Computational Complexity: A Modern Approach. Sanjeev Arora, Boaz Barak) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad a) ESPACIO(f (n)) NESPACIO(f (n)) TIEMPO(f (n)) NTIEMPO(f (n)) b) NTIEMPO(f (n)) ESPACIO(f (n)) c) NESPACIO(f (n)) TIEMPO(kf (n)) para un k a) La demostración de a) es trivial. b) La demostración de b) se basa en la simulación de una MT no determinista mediante una determinista y que consistía en ir poniendo palabras a1...aL donde ai {1,...,k} y entonces ir simulando la MT por una determinista que en el paso i coge la opción número i. El espacio que hace falta es el espacio para escribir las palabras que es menor o igual a f (n) (recordemos que L f (n)) y el espacio para hacer la simulación de L pasos, que también es de orden f (n). En total, el espacio necesario es de orden f (n). Modelos Avanzados de Computación: Tema 3: Clases de Complejidad c) NESPACIO(f (n)) TIEMPO(kf (n)) El Método de la Alcanzabilidad: Se basa en considerar un grafo en el que los nodos son las posibles conﬁguraciones de una Máquina de Turing, y los arcos conectan conﬁguraciones tales que se puede llegar de una a otra en un paso de cálculo. Para simpliﬁcar vamos a suponer una MT con una sola cinta. Una conﬁguración es una tripleta (q,u,v). Como no se ocupa más de f (n) en espacio, la longitud de u y v es menor o igual a f (n). El número de conﬁguraciones es por tanto del orden de QB2f (n) donde B es el alfabeto de trabajo. Es decir del orden de tf (n) donde t B2. Saber si una palabra es aceptada es equivalente a saber si existe un camino desde el estado inicial a una conﬁguración que contenga un estado ﬁnal y eso se puede comprobar en tiempo O(m3) donde m es el f (n). número de nodos, en nuestro caso en orden (tf (n)) Lo que demuestra el teorema para k t3. t2f (n) (t3) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Son aquellas que veriﬁcan: f (n1) f (n) y tales que la función g(u) f (u) expresando g(u) como una secuencia de longitud g(u) (es decir usando unario) es calculable en espacio O(f (n)) y tiempo O(f (n)n). Si f (n) n es propia, entonces TIEMPO((f (n)) TIEMPO(f 2(n)) TIEMPO((f (n)) 6 TIEMPO(f 2(n)) P 6 EXP Dem. P TIEMPO(2n) TIEMPO((2n)2) EXP Si f (n) es una función de complejidad propia, entonces ESPACIO(f (n)) ESPACIO(f (n)logf (n)) ESPACIO(f (n)) 6 ESPACIO(f (n)logf (n)) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad L NL P NP PESPACIO Modelos Avanzados de Computación: Tema 3: Clases de Complejidad Teorema Si f (n) log(n) y es propia, entonces NESPACIO(f (n)) ESPACIO(f 2(n)) Corolario PESPACIO NPESPACIO Teorema Si f (n) log(n) es propia entonces NESPACIO(f (n)) CoNESPACIO(f (n)) Modelos Avanzados de Computación: Tema 3: Clases de Complejidad