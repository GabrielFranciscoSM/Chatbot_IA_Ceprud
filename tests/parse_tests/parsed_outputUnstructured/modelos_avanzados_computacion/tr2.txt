Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing En este apartado vamos a estudiar otro lenguaje de programación para manipulación de palabras, el sistema de Post-Turing. En este modelo se podrán escribir programas que actúan sobre una cinta en la que se pueden escribir o leer símbolos, ilimitada en ambas direcciones. En los cálculos asociados a este modelo siempre hay una casilla de la cinta que está activa en un momento dado. Este símbolo y solo este de la cinta se supone observado y en esta casilla solo se puede escribir un símbolo. En un paso de cálculo el símbolo de la casilla se puede leer, ejecutar una determinada instrucción en función de dicho símbolo, escribir un nuevo símbolo y entonces moverse a la casilla de la izquierda o la derecha. La diferencia con las MT es que ahora la estructura para especiﬁcar el control es más parecida a un programa en un lenguaje de programación convencional: una lista de instrucciones. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Cada instrucción puede tener una etiqueta opcional. Una etiqueta es una palabra en un alfabeto determinado. Las etiquetas las escribimos como [L] al principio de la instrucción. Hay cuatro tipo de instrucciones: Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Función Calculada La función calculada por un programa Post Turing es la función f : D B deﬁnida en el conjunto D de las entradas u A tal que el programa Post Turing llega a HALT siendo f (u) la palabra en la cinta excluyendo blancos u D. Una función calculada por un programa Post Turing se dice parcialmente calculable Post Turing. Si D A se dice que es calculable total Post Turing. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Alfabeto de entrada A {a,b,c}. El de trabajo tiene además el símbolo . [A] RIGHT [C] Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Alfabeto de entrada A {0,1}. [C] [A] [E] LEFT RIGHT IF GOTO E IF 0 GOTO A IF 1 GOTO C PRINT IF GOTO C HALT Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Alfabeto de entrada A {a}. Alfabeto de trabajo B {a,,c}. [A] [B] [C] [D] IF GOTO E PRINT c RIGHT IF a GOTO B RIGHT IF a GOTO C PRINT a LEFT IF a GOTO D IF GOTO D PRINT a RIGHT IF a GOTO A HALT [E] Si empieza con an, acaba con anan. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing [A] RIGHT IF GOTO E GOTO A Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing f (u) u1 donde u {0,1}. binario calcule u1. 3 Construir un programa Post-Turing que dadas dos cadenas ucv donde u,v {0,1} calcule si la cadena u es una subcadena de la cadena v. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Un programa con variables, viene dado por un alfabeto A de entrada, un alfabeto B de trabajo y los siguientes elementos: Una variable X de entrada, un conjunto ﬁnito de variables de trabajo Z1,...,Zl y una variable Y de salida. Un conjunto de instrucciones, opcionalmente etiquetadas, de la siguiente forma: A aA, añadir el símbolo a al principio de la variable A. A A-, Eliminar el último símbolo de A (si no es vacía). IF A ENDS a GOTO L, Si el último símbolo de A es una a seguir por la instrucción con etiqueta L. HALT, termina y acepta. Se supone que empieza con X u donde u A es el valor de la entrada y con el resto de las variables conteniendo la palabra vacía ε. Acepta una palabra si llega a HALT. Calcula una función parcial f si llega a HALT con f (u) almacenado en Y deﬁnida en el conjunto de palabras para las que el programa termina. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa que tiene como entrada X u y calcula Y u sobre el alfabeto {0,1} [A] [B] IF X ENDS 0 GOTO A IF X ENDS 1 GOTO B HALT X X- Y 0Y IF X ENDS 0 GOTO A IF X ENDS 1 GOTO B HALT X X- Y 1Y IF X ENDS 0 GOTO A IF X ENDS 1 GOTO B HALT Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing La macro IF V 6 ε GOTO L con expansión: donde {a1,...,an} es el alfabeto de trabajo. La macro V ε tiene la expansión: [L] V V- IF V 6 ε GOTO L La macro GOTO L tiene la expansión: Z ε Z aZ IF Z ENDS a GOTO L Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing (i1,...,n) Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing La macro U V se expande como: [A] [Bi] [C] [Di] Z ε U ε IF V ENDS ai GOTO Bi GOTO C V V- U aiU Z aiZ GOTO A IF Z ENDS ai GOTO Di GOTO E Z Z- V aiV GOTO C i1,...,n i1,...,n (i1,...,n) (i1,...,n) Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Ejemplo: Sumar Vamos a suponer que A {a1,...,an} y que vamos a calcular la función f (n) n1, donde se supone que el número n se codiﬁca como C(n) en dicho alfabeto. IF X ENDS ai GOTO Ai Y a1Y HALT X X- Y ai1Y GOTO C X X- Y a1Y GOTO B IF X ENDS ai GOTO Di HALT X X- Y aiY GOTO C [B] (i1,...,n) [Ai] i1,...,n- [An] (i1,...,n) [C] [Di] i1,...,n Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Ejemplo: Restar Vamos a suponer que A {a1,...,an} y que vamos a calcular la función f (n) n 1 (n1 si n 1 y 0 si n 1), donde se supone que el número n se codiﬁca como C(n) en dicho alfabeto. [B] [Ai] [A1] [C2] [C] [Di] IF X ENDS ai GOTO Ai HALT X X- Y ai1Y GOTO C X X- IF X 6 ε GOTO C2 HALT Y anY GOTO B IF X ENDS ai GOTO Di HALT X X- Y aiY GOTO C i2,...,n i1,...,n (i1,...,n) (i1,...,n) Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing En muchas ocasiones queremos calcular una función f (u1,...,un) que depende de varias variables. Esto se puede hacer de la siguiente forma: Transformarla en una función que dependa de un sólo argumento añadiendo un símbolo separador c que no esté en el alfabeto de entrada y calcular f (u1c ...cun). Se entiende que el cálculo de f es equivalente al cálculo de f . En programas con variables es más sencillo suponer que existen n variables de entrada X1,...,Xn y que cada una de ellas contiene al principio uno de los argumentos de entrada: Xi ui. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Los siguientes hechos son equivalentes: Los siguientes hechos son equivalentes: L es aceptado por una MT L es aceptado por un programa Post-Turing. L es aceptado por un programa con variables. La demostración se basa en comprobar que los tres modelos se pueden simular entre si. Haremos las siguientes simulaciones: Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (1) Vamos a suponer l mk 1 y vamos a escribir las variables en el mismo orden como El programa Post-Turing va a contener el contenido de las variables de la siguiente forma en la cinta: X1 ... Xm Z1 ... Zk Y V1 ... Vj ... Vl suponiendo que las variables nunca contienen un blanco. En otro caso habría que usar otro separador en lugar de . Al pincipio de cada instrucción del programa de variables el cabezal de lectura estará situado en el blanco justo a la izquierda de V1. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (2) Vamos a simular cada instrucción del programa con variables como una macro del programa Post-Turing. Antes necesitamos una serie de macros: La macro GOTO L se expande como: La macro RIGHT TO NEXT BLANK se expande como [A] RIGHT IF GOTO E GOTO A [E] es la etiqueta de la instrucción inmediatamente después de la macro. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (3) La macro LEFT TO NEXT BLANK se expande como [A] LEFT IF GOTO E GOTO A [E] es la etiqueta de la instrucción inmediatamente después de la macro. La macro MOVE BLOCK RIGHT se expande como: [C] [Ai] [A0] LEFT IF GOTO A0 IF ai GOTO Ai RIGHT PRINT ai LEFT GOTO C RIGHT PRINT LEFT (i1,...,n) i1,...,n ...0011 ...001 Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (3) La macro LEFT TO NEXT BLANK se expande como [A] LEFT IF GOTO E GOTO A [E] es la etiqueta de la instrucción inmediatamente después de la macro. La macro MOVE BLOCK RIGHT se expande como: [C] [Ai] [A0] LEFT IF GOTO A0 IF ai GOTO Ai RIGHT PRINT ai LEFT GOTO C RIGHT PRINT LEFT (i1,...,n) i1,...,n ...0011 ... ...001 Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (3) La macro LEFT TO NEXT BLANK se expande como [A] LEFT IF GOTO E GOTO A [E] es la etiqueta de la instrucción inmediatamente después de la macro. La macro MOVE BLOCK RIGHT se expande como: [C] [Ai] [A0] LEFT IF GOTO A0 IF ai GOTO Ai RIGHT PRINT ai LEFT GOTO C RIGHT PRINT LEFT (i1,...,n) i1,...,n ...0011 ... ...001 ... Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (4) [A] RIGHT IF GOTO E PRINT GOTO A Si tenemos que repetir la misma instrucción varias veces, esto lo valos a representar con un [i] después de la instrucción donde i es el número de veces que hay que repetir la instrucción. Así RIGHT TO NEXT BLANK [3] es una forma resumida de poner: Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (5) La instrucción Vj aiVj se simula como: RIGHT TO NEXT BLANK[l] MOVE BLOCK RIGHT[l-j1] RIGHT PRINT ai LEFT TO NEXT BLANK[j] V1 ... Vj ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (5) La instrucción Vj aiVj se simula como: RIGHT TO NEXT BLANK[l] MOVE BLOCK RIGHT[l-j1] RIGHT PRINT ai LEFT TO NEXT BLANK[j] V1 ... Vj ... Vl V1 ... Vj ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (5) La instrucción Vj aiVj se simula como: RIGHT TO NEXT BLANK[l] MOVE BLOCK RIGHT[l-j1] RIGHT PRINT ai LEFT TO NEXT BLANK[j] V1 ... Vj ... Vl V1 ... Vj ... Vl V1 ... Vj ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (5) La instrucción Vj aiVj se simula como: RIGHT TO NEXT BLANK[l] MOVE BLOCK RIGHT[l-j1] RIGHT PRINT ai LEFT TO NEXT BLANK[j] V1 ... Vj ... Vl V1 ... Vj ... Vl V1 ... Vj ... Vl V1 ... ai Vj ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (5) La instrucción Vj aiVj se simula como: RIGHT TO NEXT BLANK[l] MOVE BLOCK RIGHT[l-j1] RIGHT PRINT ai LEFT TO NEXT BLANK[j] V1 ... Vj ... Vl V1 ... Vj ... Vl V1 ... Vj ... Vl V1 ... ai Vj ... Vl V1 ... ai Vj ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (6) La instrucción Vj Vj- se simula como: [C] RIGHT TO NEXT BLANK[j] LEFT IF GOTO C MOVE BLOCK RIGHT[j] RIGHT GOTO E LEFT TO NEXT BLANK[j-1] V1 ... 0011 ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (6) La instrucción Vj Vj- se simula como: [C] RIGHT TO NEXT BLANK[j] LEFT IF GOTO C MOVE BLOCK RIGHT[j] RIGHT GOTO E LEFT TO NEXT BLANK[j-1] V1 ... 0011 ... Vl V1 ... 0011 ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (6) La instrucción Vj Vj- se simula como: [C] RIGHT TO NEXT BLANK[j] LEFT IF GOTO C MOVE BLOCK RIGHT[j] RIGHT GOTO E LEFT TO NEXT BLANK[j-1] V1 ... 0011 ... Vl V1 ... 0011 V1 ... 011 ... Vl ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (6) La instrucción Vj Vj- se simula como: [C] RIGHT TO NEXT BLANK[j] LEFT IF GOTO C MOVE BLOCK RIGHT[j] RIGHT GOTO E LEFT TO NEXT BLANK[j-1] V1 ... 0011 V1 ... 011 ... Vl V1 ... 0011 ... Vl ... Vl V1 ... ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (6) La instrucción Vj Vj- se simula como: [C] RIGHT TO NEXT BLANK[j] LEFT IF GOTO C MOVE BLOCK RIGHT[j] RIGHT GOTO E LEFT TO NEXT BLANK[j-1] V1 ... 0011 V1 ... 011 ... Vl V1 ... 0011 ... Vl ... Vl V1 ... V1 ... ... Vl ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (6) La instrucción Vj Vj- se simula como: [C] RIGHT TO NEXT BLANK[j] LEFT IF GOTO C MOVE BLOCK RIGHT[j] RIGHT GOTO E LEFT TO NEXT BLANK[j-1] V1 ... 0011 V1 ... 011 ... Vl V1 ... 0011 ... Vl ... Vl V1 ... V1 ... ... Vl ... Vl V1 ... ... Vl Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (7) La instrucción IF Vj ENDS ai GOTO L se simula como: [C] [D] RIGHT TO NEXT BLANK[j] LEFT IF ai GOTO C GOTO D LEFT TO NEXT BLANK[j] GOTO L RIGHT LEFT TO NEXT BLANK[j] V1 ... 0011 ... Vl Por último, la instrucción HALT ha de simularse borrando la entrada y las variables intermedias mediante ERASE BLOCK [l-1] y parando. Si es para aceptar un lenguaje, no hace falta borrar la entrada y las variables intermedias. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (7) La instrucción IF Vj ENDS ai GOTO L se simula como: [C] [D] RIGHT TO NEXT BLANK[j] LEFT IF ai GOTO C GOTO D LEFT TO NEXT BLANK[j] GOTO L RIGHT LEFT TO NEXT BLANK[j] V1 ... 0011 ... Vl V1 ... 0011 ... Vl Por último, la instrucción HALT ha de simularse borrando la entrada y las variables intermedias mediante ERASE BLOCK [l-1] y parando. Si es para aceptar un lenguaje, no hace falta borrar la entrada y las variables intermedias. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa con Variables - Programa Post-Turing (7) La instrucción IF Vj ENDS ai GOTO L se simula como: [C] [D] RIGHT TO NEXT BLANK[j] LEFT IF ai GOTO C GOTO D LEFT TO NEXT BLANK[j] GOTO L RIGHT LEFT TO NEXT BLANK[j] V1 ... 0011 ... Vl V1 ... 0011 V1 ... 0111 ... Vl ... Vl Por último, la instrucción HALT ha de simularse borrando la entrada y las variables intermedias mediante ERASE BLOCK [l-1] y parando. Si es para aceptar un lenguaje, no hace falta borrar la entrada y las variables intermedias. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa Post Turing - MT (1) La MT tendrá un estado qi por cada instrucción Ii del programa Post Turing, más un estado qf que será el estado ﬁnal y otro estado qk1 sin transiciones donde k es el número de instrucciones del programa. Si la instrucción Ii es PRINT ai entonces pondremos las transiciones: δ(qi,a) (qi1,ai,S), a B Si la instrucción Ii es RIGHT entonces pondremos las transiciones: δ(qi,a) (qi1,a,D), a B Si la instrucción Ii es LEFT entonces pondremos las transiciones: δ(qi,a) (qi1,a,I), a B Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa Post Turing - MT (2) Si la instrucción Ii es IF ak GOTO Ij entonces pondremos las transiciones: δ(qi,ak) (qj,ak,S) y δ(qi,a) (qi1,a,S), si a 6 ak. Si la instrucción Ii es HALT ponemos las transiciones: δ(qi,a) (qf ,a,S), a B Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con variables (1) La MT y el programa con variables tendrán los mismos alfabetos. Supongamos que el alfabeto de trabajo B {a1,...,an} incluyendo el blanco. El programa con variables tendrá tres variables básicas X,Z,Y (más otras auxiliares que aparezcan como expansión de macros) Inicialmente X tendrá la palabra de entrada. La idea es que, en cada momento, la variable X contenga lo que hay a la izquierda del cabezal de lectura, Z el símbolo que ve el cabezal de lectura e Y lo que hay a la derecha. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con variables (2) Necesitamos una serie de macros: La macro V -V (eliminar el primer símbolo de V si la variable no es vacía) se expande como (U es una nueva variable auxiliar especíﬁca para la macro): U ε IF V ENDS ai GOTO Bi GOTO C V V- U aiU GOTO A IF U ENDS ai GOTO Di GOTO E U U- IF U 6 ε GOTO Fi GOTO C V aiV GOTO C [A] (i1,...,n) [Bi] i1,...,n [C] (i1,...,n) [Di] i1,...,n [Fi] E es la etiqueta de la primera instrucción después de la macro. Se copia V en U símbolo a símbolo y después se copia U en V excepto el último símbolo (que iría al principio de V) Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con variables (3) La macro V Vai (añade ai) al ﬁnal de V tiene la expansión: U ε U aiU IF V ENDS ai GOTO Bi GOTO C V V- U aiU GOTO A IF U ENDS ai GOTO Di GOTO E U U- V aiV GOTO C [A] (i1,...,n) [Bi] i1,...,n [C] (i1,...,n) [Di] [E] es la instrucción después de la macro. Se copia V en U símbolo a símbolo, se añade a a V después se copian lo símbolos de U en V, a quedaría al ﬁnal de V i1,...,n Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con variables (4) La IF V STARS ai GOTO L (Si V comienza con ai seguir por la instruccion [L] tiene la expansión: U ε IF V ENDS aj GOTO Bj GOTO E V V- U ajU IF V 6 ε GOTO A V U GOTO E GOTO L [A] (j1,...,n) [Bj] E es la etiqueta de la primera instrucción después de la macro. Se copia V en U símbolo a símbolo hasta que veamos el primero, entonces volvemos a recopiar U en V se ejecuta la acción que corresponda a ese símbolo j1,...,n (si i 6 j) (si i j) Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con variables (5) Inicialmente se ejecutarán las instrucciones: Y ε Z ε Z Z IF X ENDS ai GOTO Bi GOTO A0 X X- Z ε Z aiZ IF X 6 ε GOTO Di GOTO A Y aiY GOTO A [A] (i1,...,n) [Bi] i1,...,n [Di] Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con variables (6) Asociaremos a cada estado qi una etiqueta Ai y a cada par (qi,aj) otra etiqueta Bij donde se simulará la transición δ(qi,aj). Todas las transiciones no deﬁnidas se pueden asociar a la misma etiqueta E. En las etiquetas Ai hay las siguientes instrucciones para los estados no ﬁnales: Ai En las etiquetas Ai correspondientes a un estado ﬁnal tendremos las instrucciones que ponen toda la cinta en Y: [Ci] [B] [Di] IF Z ENDS ai GOTO Ci Y aiY GOTO B IF X ENDS ai GOTO Di HALT Y aiY X X- GOTO B i1,...,n (cid:27) i1,...,n (i1,...,n) (i1,...,n) Antes de parar habría que quitar los blancos a la derecha y a la izquierda de Y. Podeis añadir las instrucciones necesarias como ejercicio. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing MT - Programa con Variables (7) Si tenemos la transición δ(qi,aj) (qm,ak,D), entonces ponemos el grupo de instrucciones: [Bij] X Xak Z ε IF Y STARS al GOTO Cml Z Z GOTO Am Y -Y Z alZ GOTO Am (l1,...,n) [Cml] l1,...,n Si tenemos la transición δ(qi,aj) (qm,ak,I), entonces ponemos el grupo de Y akY Z ε IF X ENDS al GOTO Dml Z Z GOTO Am X X- Z alZ GOTO Am [Bij] (l1,...,n) instrucciones: [Dml] l1,...,n Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Hasta ahora, hemos visto que los modelos de cálculo trabajan con palabras, pero ¿es posible considerar modelos que trabajan con números? Ya hemos visto una aplicación biyectiva entre las palabras de cualquier alfabeto A y el conjunto de los números naturales N que habíamos llamado N (el número asociado a una palabra), siendo su inversa C (la palabra asociada a un número). De esta forma cualquier modelo de cálculo con palabras lo podemos interpretar como un modelo de cálculo con números.Una función numérica f (n) deﬁnida sobre los números naturales podemos considerar que se calcula con un modelo de palabras en el que: Ponemos como entrada u C(n), la palabra que codiﬁca el número n Si la salida es w, la interpretamos como el número f (n) N(w) (el número representado por w). Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Ejemplo Si queremos calcular f (n) n2, representamos cada número n en un alfabeto, p.e. {a,b} como la palabra C(n) y hacemos un progra- ma (MT, programa Post-Turing, etc.) que calcule la palabra w que represente el valor n2. Así se puede deﬁnir el concepto de función parcialmente calculable de números: cuando exista una codiﬁcación en un alfabeto que la calcule. Una función es recursiva o calculable cuando es parcialmente calculable y total (está deﬁnida en los números naturales). También se puede deﬁnir el concepto de conjunto numérico recursivo o recursivamente enumerable: cuando el conjunto de todas sus codiﬁcaciones en un alfabeto sea recursivo o recursivamente enumerable. Estas deﬁniciones no dependen del alfabeto que se use para la codiﬁcacion. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Ejemplo: Sumar Vamos a suponer que A {a1,...,an} y que vamos a calcular la función f (n) n1, donde se supone que el número n se codiﬁca como C(n) en dicho alfabeto. IF X ENDS ai GOTO Ai Y a1Y HALT X X- Y ai1Y GOTO C X X- Y a1Y GOTO B IF X ENDS ai GOTO Di HALT X X- Y aiY GOTO C [B] (i1,...,n) [Ai] i1,...,n- [An] (i1,...,n) [C] [Di] i1,...,n Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Un programa con variables numéricas tiene los siguientes elementos: Un conjunto X1,...,Xk de variables de entrada, un conjunto ﬁnito de variables de trabajo Z1,...,Zl y una variable Y de salida. Un conjunto de instrucciones opcionalmente etiquetadas de la siguiente forma: A A1, Añade 1 al valor entero almacenado en A. A A-1, Resta 1 del valor almacenado en A (si es 0 sigue siendo 0). IF A 6 0 GOTO L, Si el valor de A no es 0, seguir por la instrucción con etiqueta L. HALT, termina y acepta. Se supone que empieza con Xi ni donde u N son los valores de entrada y el resto de las variables conteniendo 0. Acepta una entrada si llega a HALT y calcula una función parcial f si llega a HALT con f (n1,...,nk) almacenado en Y cuando f está deﬁnida y no para en otro caso. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Programa que tiene como entrada X n y calcula Y n, excepto para X 0 que Y 1. Es decir, calcula la función f (n) n si n 6 0 y f (0) 1. [A] X X-1 Y Y1 IF X 6 0 GOTO A HALT Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing La macro V 0 con expansión: [A] V V-1 IF V 6 0 GOTO A La macro GOTO L con expansión: [A] Z Z1 IF Z 6 0 GOTO L Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing La macro V U tiene la expansión: [A] [B] [C] V 0 Z 0 IF U 6 0 GOTO B IF Z 6 0 GOTO C HALT V V1 Z Z1 U U-1 GOTO A U U1 Z Z-1 IF Z 6 0 GOTO C HALT Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Teorema Una función f : A N es parcialmente calculable por un programa con números si y solo si es parcialmente calculable utilizando una codiﬁcación con palabras. No lo vamos a demostrar. La demostración se basa en simular las instrucciones de un programa con números mediante un programa con cadenas que trabaje con las codiﬁcaciones de esos números en un alfabeto y recíprocamente. Algunas de estas simulaciones se han visto ya y otras se han propuesto como ejercicios. Se pueden deﬁnir conceptos de subconjunto A N r.e. y recursivo (calculable), por ejemplo considerando que un número n es aceptado cuando para X n el programa termina en HALT con Y 1. Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing Toda función efectivamente calculable (calculable mediante un proceso mecánico bien deﬁnido) puede ser calculada por una Máquina de Turing. Es una tesis que no puede ser comprobada matemáticamente si no se da una deﬁnición formal de efectivamente calculable, pero eso es precisamente lo que intenta hacer la tesis de Church Turing. Es una tesis que es aceptada como cierta. Aunque consideremos modelos de computación cuántica, no permitirían hacer cálculos más allá de los realizados por una MT (aunque quizá en menos tiempo que una MT). Tema 2: Otros Modelos de Cálculo: Tesis de Church-Turing