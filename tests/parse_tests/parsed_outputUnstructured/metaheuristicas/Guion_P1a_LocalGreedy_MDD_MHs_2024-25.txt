Práctica 1.a Técnicas de Búsqueda de Poblaciones para el Problema de la Mínima Dispersión Diferencial (MDD) El objetivo de esta práctica es estudiar el funcionamiento de las Técnicas de Búsqueda Local y de los Algoritmos Greedy en la resolución del Problema de la Mínima Dispersión Diferencial (MDD) descrito en las transparencias del Seminario 2. Para ello, se requerirá que el estudiante adapte los siguientes algoritmos a dicho problema: Algoritmos de Búsqueda Local (BL). La práctica se evalúa sobre un total de 2 puntos, distribuidos de la siguiente forma: BL (1 puntos). Random (0.5 puntos). Greedy (0.5 puntos). La fecha límite de entrega será el el martes 1 de abril de 2025 antes de las 23:55 horas. La entrega de la práctica se realizará por internet a través del espacio de la asignatura en PRADO. El problema de la mínima dispersión diferencial (en inglés, minimum differential dispersion problem, MDD) es un problema de optimización combinatoria consistente en seleccionar un subconjunto M de m elementos (Mm) de un conjunto inicial N de n elementos (con nm) de forma que se minimice la dispersión entre los elementos escogidos. El MDD se puede formular como: Minimizar MaxxiM MinxiM con M N,M m jM jM donde: Se utilizarán 50 casos seleccionados de varios de los conjuntos de instancias disponibles en la MDPLIB ( todas pertenecientes al grupo GDK con distancias aleatorias: 50 del grupo GDK-b con distancias reales con, n entre {25, 50, 75, 100, 125, 150}, y m entre 2 y 45 (GDK-bGKD-b_1_n25_m2.txt a GKD-b_50_n150_m45.txt), El fichero Tablas_MDD_2024-25.xls, disponible en el espacio de PRADO y la web de la asignatura, incluye las características (nombre, tamaño y coste de la mejor solución conocida) de las instancias seleccionadas. Aunque pueden ser descargados de la MDPLib, los ficheros de los 50 casos se han incluido también en las dos localizaciones del espacio de la asignatura (PRADO y web externa) para facilitar el trabajo al estudiantado. El formato de los ficheros es el siguiente: n(n-1)/2 líneas con el formato i j dij (i, j{0, ..., n-1}) que recogen el contenido de la matriz de distancias entre los elementos. Se almacena sólo la diagonal superior. Ejemplo (GKD-b_50_n150_m45): Como algoritmo de BL para el MDD consideraremos el esquema del primero mejor, tal y como está descrito en las transparencias del Seminario 2. La representación será en forma de un conjunto de elementos seleccionados. Se empleará el movimiento de intercambio Int(Sel,i,j) que intercambia el elemento seleccionado i por uno no seleccionado j en la solución actual Sel. Será obligatorio emplear la factorización de la función objetivo en todos los casos. Una vez realizado el movimiento, se actualiza la solución actual y los valores de contribución de los elementos seleccionados al coste de dicha solución, y se comienza a explorar el nuevo entorno. La exploración del entorno se realizará de forma distinta según dos opciones: En orden totalmente aleatorio (randLS). En orden ascendente de contribución de los elementos seleccionados al coste de la solución actual (heurLS). Cuando se analiza el comportamiento de un algoritmo probabilístico en un caso de un problema, se desearía que el resultado obtenido no estuviera sesgado por una secuencia aleatoria concreta que pueda influir positiva o negativamente en las decisiones tomadas durante su ejecución. Por tanto, resulta necesario efectuar varias ejecuciones con distintas secuencias probabilísticas y calcular el resultado medio (y a veces la desviación típica) de todas las ejecuciones para representar con mayor fidelidad su comportamiento. Dada la influencia de la aleatoriedad en el proceso, es recomendable disponer de un generador de secuencia pseudoaleatoria de buena calidad con el que, dado un valor semilla de inicialización, se obtengan números en una secuencia lo suficientemente grande (es decir, que no se repitan los números en un margen razonable) como para considerarse aleatoria. En el espacio de PRADO se puede encontrar una implementación en lenguaje C de un generador aleatorio de buena calidad (random.hpp). Como norma general, el proceso a seguir consiste en realizar un número de ejecuciones diferentes de cada algoritmo probabilístico considerado para cada caso del problema. Es necesario asegurarse de que se realizan diferentes secuencias aleatorias en dichas ejecuciones. Así, el valor de la semilla que determina la inicialización de cada secuencia deberá ser distinto en cada ejecución y estas semillas deben mantenerse en los distintos algoritmos (es decir, la semilla para la primera ejecución de todos los algoritmos debe ser la misma, la de la segunda también debe ser la misma y distinta de la anterior, etc.). Por simplificar y facilitar la reproducibilidad, se usará la misma semilla para todos los casos de uso. Para mostrar los resultados obtenidos con cada algoritmo en el que se hayan realizado varias ejecuciones, se suelen construir tablas que recojan los valores correspondientes a estadísticos como el mejor y peor resultado para cada caso del problema, así como la media y la desviación típica de todas las ejecuciones. También se pueden emplear descripciones más representativas como los boxplots, que proporcionan información de todas las ejecuciones realizadas mostrando mínimo, máximo, mediana y primer y tercer cuartil de forma gráfica. Finalmente, se construirán unas tablas globales con los resultados agregados que mostrarán la calidad del algoritmo en la resolución del problema desde un punto de vista general. Para cada algoritmo ejecutado, se ejecutará 5 veces para cada instancia, cada uno con un valor de semilla distinto, y se indicará la media tanto en tiempos como en coste final obtenido. Será necesario inicializar las semillas del generador aleatorio para poder repetir el experimento y obtener los mismos resultados si fuera necesario (en caso contrario, los resultados podrían variar en cada ejecución del mismo algoritmo sobre el mismo caso del problema). Para facilitar la comparación de algoritmos en las prácticas del MDP se considerarán dos estadísticos distintos denominados Desv y Tiempo: Desv se calcula como la media de las desviaciones, en porcentaje, del valor obtenido por cada método en cada instancia respecto al mejor valor conocido para ese caso. Es decir, para un problema de minimización como el MDD: Desv 100 iCasos ValorAlgoritmoi MejorValori ValorAlgoritmoi Cuanto menor es el valor de Desv para un algoritmo, mejor calidad tiene dicho algoritmo, porque en media obtiene soluciones más cercanas al mejor valor conocido. Por otro lado, si dos métodos obtienen soluciones de la misma calidad (tienen valores de Desv similares), uno será mejor que el otro si emplea menos tiempo en media. En la web de la asignatura hay también disponible un código en C (timer) para un cálculo adecuado del tiempo de ejecución de los algoritmos metaheurísticos. Como algoritmo de BL para el MDD consideraremos el esquema del primer mejor, tal y como está descrito en las transparencias del Seminario 2. La representación será en forma de un conjunto de elementos seleccionados. Se diseñará una tabla para cada algoritmo (Greedy, LSrandom, LSheur) donde se recojan los resultados de la ejecución de dicho algoritmo al conjunto de casos del problema. Tendrá la misma estructura que la tabla 1. Tabla 1: Resultados obtenidos por el Algoritmo X en el MDD Tabla 2: Resultados globales por Tamaño en el MDD Tabla 3: Resultados globales totales en el MDD En general, la documentación de ésta y de cualquier otra práctica será un fichero pdf que deberá incluir, al menos, el siguiente contenido: a) Portada con el número y título de la práctica (con el nombre del problema), el curso académico, b) Índice del contenido de la documentación con la numeración de las páginas. c) Breve descripción/formulación del problema (máximo 1 página). Podrá incluirse el mismo d) Breve descripción de la aplicación de los algoritmos empleados al problema (máximo 4 páginas): Todas las consideraciones comunes a los distintos algoritmos se describirán en este apartado, que será previo a la descripción de los algoritmos específicos. Incluirá por ejemplo la descripción del esquema de representación de soluciones y la descripción en pseudocódigo (no código) de la función objetivo y los operadores comunes. e) Descripción en pseudocódigo de la estructura del método de búsqueda y de todas aquellas operaciones relevantes de cada algoritmo. Este contenido, específico a cada algoritmo se detallará en los correspondientes guiones de prácticas. El pseudocódigo deberá forzosamente reflejar la implementación/ el desarrollo realizados y no ser una descripción genérica extraída de las transparencias de clase o de cualquier otra fuente. La descripción de cada algoritmo no deberá ocupar más de 2 páginas. Para esta primera práctica, se incluirán al menos las descripciones en pseudocódigo de: f) Breve explicación de la estructura del código de la práctica, incluyendo un pequeño manual de usuario describiendo el proceso para que el profesor de prácticas pueda compilarlo (usando un sistema automático como make o similar) y cómo ejecutarlo, dando algún ejemplo de ejecución. g) Experimentos y análisis de resultados: Descripción de los casos del problema empleados y de los valores de los parámetros considerados en las ejecuciones de cada algoritmo (incluyendo las semillas utilizadas). Análisis de resultados. El análisis deberá estar orientado a justificar (según el compor- tamiento de cada algoritmo) los resultados obtenidos en lugar de realizar una mera lectura de las tablas. Se valorará la inclusión de otros elementos de comparación tales como gráficas de convergencia, boxplots, análisis comparativo de las soluciones obtenidas, representación gráfica de las soluciones, etc. h) Referencias bibliográficas u otro tipo de material distinto del proporcionado en la asignatura que se haya consultado para realizar la práctica (en caso de haberlo hecho). En lo referente al desarrollo de la práctica, se entregará una carpeta llamada software que contenga una versión ejecutable de los programas desarrollados, así como el código fuente imple- mentado o los ficheros de configuración del framework empleado. El código fuente o los ficheros de configuración se organizarán en la estructura de directorios que sea necesaria y deberán colgar del directorio src en el raíz. Junto con el código fuente, hay que incluir los ficheros necesarios para construir los ejecutables según el entorno de desarrollo empleado (tales como .prj, makefile, .ide, etc.). En este directorio se adjuntará también un pequeño fichero de texto de nombre LEEME que contendrá breves reseñas sobre cada fichero incluido en el directorio. Es importante que los programas realizados puedan leer los valores de los parámetros de los algoritmos desde fichero, es decir, que no tengan que ser recompilados para cambiar éstos ante una nueva ejecución. Por ejemplo, la semilla que inicializa la secuencia pseudoaleatoria debería poder especificarse como un parámetro más. El fichero pdf de la documentación y la carpeta software serán comprimidos en un fichero .zip etiquetado con los apellidos y nombre del estudiante (Ej. Pérez Pérez Manuel.zip). Este fichero será entregado por internet a través del espacio de la asignatura en PRADO. Al principio de la práctica se ha indicado la puntuación máxima que se puede obtener por cada algoritmo y su análisis. La inclusión de trabajo voluntario (desarrollo de variantes adicionales, experimentación con diferentes parámetros, prueba con otros operadores o versiones adicionales del algoritmo, análisis extendido, etc.) podrá incrementar la nota final por encima de la puntuación máxima definida inicialmente, o compensar parcialmente errores en la práctica. En caso de que el comportamiento del algoritmo en la versión implementada/ desarro- llada no coincida con la descripción en pseudocódigo o no incorpore las componentes requeridas, se podría reducir hasta en un 50 la calificación del algoritmo correspon- diente.