Tema 1. Introducción a las Metaheurísticas Tema 2. Modelos de Búsqueda: Entornos y Tema 3. Metaheurísticas Basadas en Poblaciones Tema 4: Algoritmos Meméticos Tema 5. Metaheurísticas Basadas en Trayectorias Tema 6. Metaheurísticas Basadas en Adaptación Social Tema 7. Aspectos Avanzados en Metaheurísticas Tema 8. Metaheurísticas Paralelas Tema 9. Modelos de IA Evolutivos. Aprendizaje Analizar las características de las técnicas basadas en Entender el funcionamiento y estructura general de los algoritmos de optimización simples basados en búsquedas locales. Ante un problema abordable mediante este tipo de Entender el concepto de algoritmo basado en ALGORÍTMICA TEMA 2. Modelos de Búsqueda: Entornos y Trayectorias vs Poblaciones E.-G. Talbi. Metaheuristics. From design to implementation. Wiley, 2009 J. Brownlee. Clever Algorithms (Nature-Inspired Programming Recipes). 2012, Brownlee.  1.1. Término LOCAL . Estructura de entorno. Proceso 1.1. Término LOCAL . Estructura de entorno. Proceso El término local se utiliza frecuentemente en los estudios teóricos y prácticos de las metaheurísticas de búsqueda. 1.1. Término LOCAL )(0σN )(1σN )(2σN )(4σN Óptimo local/global )(3σN Se fija una codificación para las soluciones. Se define un operador de generación de vecino y, en consecuencia, Se escoge una solución del entorno de la solución actual hasta que Proceso de elección de la solución inicial. Operador de vecino: Proceso de selección de solución/generación de una solución vecina: S S, S E(S) (también notado N(S)). Proceso de aceptación de solución vecina como solución actual. )(0σN )(1σN )(2σN )(4σN )(3σN Óptimo local/global GENERA(Solución Inicial) Solución Actual Solución Inicial; Mejor Solución Solución Actual; Solución Vecina GENERA_VECINO(Solución Actual); Si Acepta(Solución Vecina) entonces Solución Actual Solución Vecina; Si Objetivo(Solución Actual) es mejor que Objetivo(Mejor Solución) entonces Mejor Solución Solución Actual; Hasta (Criterio de parada); DEVOLVER (Mejor Solución); Se podría tener un modelo que seleccione soluciones, opere con ellas y puedan ser reinsertadas en la población dando lugar a una nueva población. Podemos imitar a la genética, cómo se combinan cromosomas (algoritmos genéticos) Se podría tener un modelo que seleccione soluciones, opere con ellas y puedan ser reinsertadas en la población dando lugar a una nueva población. Podemos imitar a la evolución de especies y la genética, cómo se combinan cromosomas (algoritmos genéticos) ¿Otras propuestas de obtención de poblaciones? Se podría tener un modelo que seleccione soluciones, opere con ellas y puedan ser reinsertadas en la población dando lugar a una nueva población. Podemos imitar a la evolución de especies y la genética, cómo se combinan cromosomas (algoritmos genéticos) ¿Otras propuestas de obtención de poblaciones? ¿Otras propuestas de Metaheurísticas?  Se elige aleatoriamente una muestra de soluciones del espacio de Se diría que el entorno de una solución es todo el espacio de búsqueda: E(s) todo el espacio de búsqueda. GENERA(Solución Inicial) Solución Actual Solución Inicial; Mejor Solución Solución Actual; GENERA(Solución Actual); Si Objetivo(Solución Actual) es mejor que Objetivo(Mejor Solución) Generación Aleatoria entonces Mejor Solución Solución Actual; Hasta (Criterio de parada); DEVOLVER (Mejor Solución); EJEMPLO: Búsqueda Aleatoria Pura para el Viajante de Comercio probabilidad de que al generar aleatoriamente una solución se obtenga la óptima es 1/m. absoluta de obtener el óptimo en la iteración i: P(Ai) 1/m i 1, , n. La probabilidad de obtener el óptimo en n iteraciones sería: P(A1 A2 An) P(A1 A2 An) Si es tal que 0 1 (probabilidad a priori de error en la búsqueda, es decir, probabilidad de que la BA no encuentre el óptimo), entonces: Es decir, n sería el nº de iteraciones necesario para garantizar la obtención del óptimo con probabilidad 1- EJEMPLO: Valores de n (número de iteraciones necesario) para distintos valores de la probabilidad de fallo y del tamaño del espacio de búsqueda m Pfall o 0.1 0.2 0.3 0.4 0.1 0.2 0.3 0. Péxito 1- Pfall o 0.1 0.2 0.3 0.4 0.1 0.2 0.3 0. Péxito 1- Se obtiene desde la descripción de una Búsqueda por Entornos. La solución inicial se genera aleatoriamente. El entorno de cualquier solución es propio (no consta de todas las soluciones del espacio de búsqueda). La solución vecina a la solución actual se escoge aleatoriamente dentro del Se almacena la mejor solución obtenida hasta el momento. Ésta es la solución que En definitiva, puede considerarse como una búsqueda local en la que se acepta el primer vecino generado, independientemente de que sea mejor o peor que la solución actual. )(0σN )(1σN )(2σN )(4σN )(3σN Óptimo local/global 3.1. Introducción. Procedimiento Base 3.2. Búsqueda Local del Mejor 3.3. Búsqueda Local del Primer Mejor 3.4. Ejemplo: Viajante de Comercio 3.5. Problemas de la Búsqueda Local Consiste en el muestreo de soluciones vecinas mejores que la actual en Hay dos versiones: del Mejor y del Primer Mejor. En ambos casos, el algoritmo devuelve la última solución visitada (no es necesario ir almacenando la mejor solución). GENERA(Solución Inicial); Solución Actual Solución Inicial; GENERA_SOLUCIÓN_ENTORNO(Solución Vecina tal que Objetivo(Solución Vecina) mejor que Objetivo(Solución Actual)); Si Objetivo(Solución Vecina) mejor que Objetivo(Solución Actual) entonces Solución Actual Solución Vecina; Hasta (Objetivo(Solución Vecina) peor o igual que Objetivo(Solución Actual), S E(Solución Actual)); DEVOLVER(Solución Actual); Steepest-Ascent Hill Climbing (best neighbor) Genera el entorno completo de la solución actual y Si ésta es mejor que la solución actual, la sustituye y se En otro caso, el algoritmo finaliza. GENERA(Sact); Repetir Mejor Vecino Sact Repetir para toda S E(Sact) S GENERA_VECINO(Sact); Si Objetivo(S) mejor que Objetivo(Mejor Vecino) entonces Mejor Vecino S; Fin-Repetir-para Si Objetivo(Mejor Vecino) mejor que Objetivo(Sact) entonces Sact Mejor Vecino; Hasta (Objetivo(Mejor Vecino) peor o igual que Objetivo(Sact)); DEVOLVER(Sact); EJEMPLO: E(s) {si / si (xi {0,1}, yi {0,1}) si s} 3.3. Búsqueda Local del Primer Mejor Simple Hill Climbing (first-best neighbor) Se va generando paso a paso el entorno de la solución actual hasta que se obtiene una solución vecina que mejora a la actual o se construye el entorno completo. En el primer caso, la solución vecina sustituye a la En el segundo, se finaliza la ejecución del algoritmo. GENERA(Sact); S GENERA_VECINO(Sact); Hasta (Objetivo(S) mejor que Objetivo(Sact)) O (se ha generado E(Sact) al completo) Si Objetivo(S) mejor que Objetivo(Sact) entonces Sact S; Hasta (Objetivo(S) peor o igual que Objetivo(Sact)); DEVOLVER(Sact); EJEMPLO: E(s) {si / si (xi {0,1}, yi {0,1}) si s} 3.4. Ejemplo: Viajante de Comercio Ejemplo: Viajante de Comercio Representación de una solución: Camino (1 2 4 3 8 5 7 6) 1. Esquema de representación: Permutación de {1, ..., n}. 2. Función objetivo: ()1,1,)( 11SnSDiSiSDSCMinni 3. Mecanismo de generación de la solución inicial: Permutación aleatoria. 4. Operador de generación de nuevas soluciones: escoger dos posiciones e intercambiar sus valores (2-opt): 5. Mecanismo de selección: Selección del mejor o el primer mejor. 6. Criterio de parada: Cuando el vecino generado no mejore a la solución actual. Otro operador: Viajante de Comercio Inversión simple (2-Opt): se escoge una sublista y se invierte (1 2 4 3 8 5 7 6) (1 2 5 8 3 4 7 6) Intercambio: se escogen dos elementos y se intercambian (1 2 4 3 8 5 7 6) (1 2 5 3 8 4 7 6) TSP: Factorización del Movimiento 2-Opt Sea f() el coste de la solución original Para generar , el operador de vecino elimina los arcos: (i)(i1) y (j) (j1), y restablece el circuito con los arcos: (i)(j1) y (j) (i1) Por lo tanto, el coste del movimiento se puede factorizar como: y la variación en el coste de f() es: f() f() f() 532! soluciones posibles Coste solución óptima 27.686 millas TSP Instancia Berlin52 Preguntas: ¿Cómo de diferente puede llegar a ser la solución vecina respecto de la solución actual según el operador de vecindario empleado? ¿Cuál es el tamaño del entorno generado por cada operador de vecino? El efecto al aplicar un operador concreto, ¿es el mismo en todos los problemas? Por ejemplo, ¿es lo mismo generar un vecino por intercambio de 2 posiciones en TSP que en otro problema? Suele caer en óptimos locales, que a veces están bastante alejados del óptimo global del problema SOLUCIONES: 3 opciones para salir de los óptimos locales Permitir movimientos de empeoramiento de la solución actual Ejemplo: Enfriamiento Simulado, Búsqueda Tabú (T5). Modificar la estructura de entornos Ejemplo: Búsqueda Tabú, Búsqueda en Entornos Variables: VNS, (T5) Volver a comenzar la búsqueda desde otra solución inicial Ejemplo: Búsquedas Multiarranque, ILS, VNS, (T5). [Tal09] [Bro12] E.-G. Talbi. Metaheuristics. From design to implementation. Wiley, 2009 J. Brownlee. Clever Algorithms (Nature-Inspired Programming Recipes). 2012, Brownlee.   Tema 1. Introducción a las Metaheurísticas Tema 2. Modelos de Búsqueda: Entornos y Tema 3. Metaheurísticas Basadas en Poblaciones Tema 4: Algoritmos Meméticos Tema 5. Metaheurísticas Basadas en Trayectorias Tema 6. Metaheurísticas Basadas en Adaptación Social Tema 7. Aspectos Avanzados en Metaheurísticas Tema 8. Metaheurísticas Paralelas Tema 9. Modelos de IA Evolutivos. Aprendizaje