3.1 Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2 Python/Julia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . La guía está planteada en C, que es el lenguaje que más se ha usado en las prácticas, aunque si alguien quisiese utilizar otro lenguaje Orientado a Objeto (OO) como Java no habría problema, siempre que aplicase el mismo criterio (con los cambios de sintaxis correspondientes). Para lenguajes no OO daré también indicaciones alternativas. El principal problema observado es que se integraba demasiado el algoritmo y el problema. Aunque teóricamente eran diseños OO en la práctica no era tal, ya que había una clase P1 para la primera práctica, P2 para la segunda, ... y quizás alguna clase con utilidades (Utils o similar), pero sin una cohesión clara. ¿Eso que problemas presenta? De todo tipo: La metaheurística depende del problema: Lo primero, la metaheurística no se puede probar hasta tener el problema concreto implementado. Si se separase, se podría probar la metaheurística con un problema de juguete (como optimizar el número total de unos en un vector binario) que permitiese ver fácilmente si el algoritmo parece funcionar mucho más fácilmente. Reutilizar código: El problema es común para todos los algoritmos. Al no hacerlo así, se producían mucho copiar y pegar entre algoritmos y prácticas, en vez de poder utilizar el Problema tal cual entre Aislar la complejidad del problema: De esta forma la complejidad del problema y la función de evaluación se aisla, con lo que el código del algoritmo no se complica debido al problema, aislando la complejidad. Pruebas independientes del problema: Una mayor separación facilita el poder probar por separado si cada parte funciona. Es decir, se puede más fácilmente darle una solución a evaluar y confirmar si el valor obtenido es correcto. Pruebas automáticas: Las pruebas anteriores pueden automatizarse. Ejemplo para representación binaria: typedef vectorbool tSolution y para una representación de números reales: typedef vectorfloat tSolution No se almacena el fitness de forma asociada directamente, ya que puede haber casos en los que no tenga sentido (una solución no válida) o bien porque se quiere postergar la evaluación de la solución. El uso de un typedef en vez de un class facilita el procesarlo de forma más clara: acceder a elementos, conocer su longitud, ..., que de la otra forma implicaría el tener que definir muchos métodos triviales y redundantes. El interfaz es el mínimo posible: virtual public : class Problem { fitness ( tSolution ); tSolution createSolution (); int getSize ( ); } Todo algoritmo implementado deberá de cumplir el siguiente interfaz: class MH { public : . . . virtual pairtSolution , tFitness optimize (Problem problem , int maxevals ) 0; }; Como se puede observar, lo principal es implementar el método optimize, que: Recibe un objeto de tipo Problem, con el que podrá evaluar las soluciones, entre otras cosas. La plantilla posee la siguiente estructura: src Implementación de las clases cuyas cabeceras se encuentran en inc/. Para compilar es necesario el software CMake. Este programa permite generar la estructura adecuada para compilar. Puede generar un Makefile, o bien proyectos para VS o para Xcode. Se recomienda la generación de Makefile. Aunque cmake genera el makefile, siempre es necesario tenerlo instalado para compilarlo: cmake . make Si se desea mejorar el rendimiento es conveniente compilar en modo "Release" en vez de en modo "Debug" cmake DCMAKE_BUILD_TYPERelease . make Aunque la plantilla está claramente pensada para C, eso es porque es el principal lenguaje usado tradicionalmente en las prácticas. Sin embargo, se puede adaptar el interfaz igualmente a otros lenguajes de programación. A continuación presentamos cómo se puede adaptar a distintos lenguajes: Para definir la clase solución se puede aplicar directamente herencia de una collección, como: class tSolution extends ArrayListsFloat {} La clase Problem puede definirse directamente como lo que es, un interfaz: public interface Problem { fitness ( tSolution ); float tSolution createSolution (); int getSize ( ); } public class MH { // . . . public PairtSolution , tFitness optimize (Problem problem , int maxevals ); }; E implementarlo como: public class Greedy extends MH { // . . . overide public PairtSolution , tFitness optimize (Problem problem , int maxevals ); } 3.2 Python/Julia