En arquitectura computacional, RISC (del inglés Reduced Instruction Set Computer, en español Computador con conjunto de instrucciones reducido) es un tipo de diseño de CPU generalmente utilizado en microprocesadores o microcontroladores con las siguientes características fundamentales:​

Instrucciones de tamaño fijo y presentadas en un reducido número de formatos.
Solo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Además estos procesadores suelen disponer de muchos registros de propósito general.
El objetivo de diseñar máquinas con esta arquitectura es posibilitar la segmentación y el paralelismo en la ejecución de instrucciones y reducir los accesos a memoria.
Las máquinas RISC protagonizan la tendencia actual de construcción de microprocesadores. PowerPC,​ DEC Alpha, MIPS, ARM, SPARC son ejemplos de algunos de ellos.
RISC es una filosofía de diseño de CPU para computadora que está a favor de conjuntos de instrucciones pequeñas y simples que toman menor tiempo para ejecutarse. El tipo de procesador más comúnmente utilizado en equipos de escritorio, el x86, está basado en CISC en lugar de RISC, aunque las versiones más nuevas traducen instrucciones basadas en CISC x86 a instrucciones más simples basadas en RISC para uso interno antes de su ejecución.
La idea fue inspirada por el hecho de que muchas de las características que eran incluidas en los diseños tradicionales de CPU para aumentar la velocidad estaban siendo ignoradas por los programas que eran ejecutados en ellas. Además, la velocidad del procesador en relación con la memoria de la computadora que accedía era cada vez más alta. Esto conllevó la aparición de numerosas técnicas para reducir el procesamiento dentro del CPU, así como de reducir el número total de accesos a memoria.
Terminología más moderna se refiere a esos diseños como arquitecturas de carga-almacenamiento.

Filosofía de diseño antes de RISC:
Uno de los principios básicos de diseño para todos los procesadores es añadir velocidad al proveerles alguna memoria muy rápida para almacenar información temporalmente, estas memorias son conocidas como registros. Por ejemplo, cada CPU incluye una orden para sumar dos números. La operación básica de un CPU sería cargar esos dos números en los registros, sumarlos y almacenar el resultado en otro registro, finalmente, tomar el resultado del último registro y devolverlo a la memoria principal.
Sin embargo, los registros tienen el inconveniente de ser algo complejos para implementar. Cada uno está representado por transistores en el chip, en este aspecto la memoria principal tiende a ser mucho más simple y económica. Además, los registros le añaden complejidad al cableado, porque la unidad central de procesamiento necesita estar conectada a todos y cada uno de los registros para poder utilizarlos por igual.
Como resultado de esto, muchos diseños de CPU limitan el uso de registros de alguna u otra manera. Algunos incluyen pocos registros, aunque esto limita su velocidad. Otros dedican sus registros a tareas específicas para reducir la complejidad; por ejemplo, un registro podría ser capaz de hacer operaciones con uno o más de los otros registros, mientras que el resultado podría estar almacenado en cualquiera de ellos.
En el mundo de la microcomputación de los años setenta, este era un aspecto más de las CPU, ya que los procesadores eran entonces demasiado lentos –de hecho había una tendencia a que el procesador fuera más lento que la memoria con la que se comunicaba-. En esos casos tenía sentido eliminar casi todos los registros, y entonces proveer al programador de una buena cantidad de maneras de tratar con la memoria para facilitar su trabajo.
Dado el ejemplo de la suma, la mayoría de los diseños de CPU se enfocaron a crear una orden que pudiera hacer todo el trabajo automáticamente: llamar los dos números que serían sumados, sumarlos, y luego almacenarlos fuera directamente. Otra versión podría leer los dos números de la memoria, pero almacenaría el resultado en un registro. Otra versión podría leer uno de la memoria y otro desde un registro y almacenarlo en la memoria nuevamente. Y así sucesivamente.
La meta en general en aquel tiempo era proveer cada posible modo de direccionamiento para cada instrucción, un principio conocido como ortogonalidad. Esto llevó a un CPU complejo, pero en teoría capaz de configurar cada posible orden individualmente, haciendo el diseño más rápido en lugar de que el programador utilizara órdenes simples.
La última representación de este tipo de diseño puede ser vista en dos equipos, el MOS 6502 por un lado, y el VAX en el otro. El chip 6502 de $25 USD efectivamente tenía solamente un registro, y con la configuración cuidadosa de la interfaz de memoria fue capaz de sobrepasar diseños corriendo a velocidades mayores (como el Zilog Z80 a 4MHz). El VAX era un minicomputador que en una instalación inicial requería 3 gabinetes de equipo para un solo CPU, y era notable por la sorprendente variedad de estilos de acceso a memoria que soportaba, y el hecho de que cada uno de estos estaba disponible para cada instrucción.

Filosofía de diseño RISC:
A finales de los setenta, investigaciones en IBM (y otros proyectos similares en otros lugares), demostraron que la mayoría de esos modos de direccionamiento ortogonal eran ignorados por la mayoría de los programas. Esto fue un efecto colateral en el incremento en el uso de compiladores para generar los programas, algo opuesto a escribirlos en lenguaje ensamblador. Los compiladores tendían a ser demasiado tontos en términos de las características que usaban, un efecto colateral del intento por hacerlos pequeños. El mercado se estaba moviendo hacia un uso más generalizado de los compiladores, diluyendo aún más la utilidad de los modelos ortogonales.
Otro descubrimiento fue que debido a que esas operaciones eran escasamente utilizadas, de hecho tendían a ser más lentas que un número pequeño de operaciones haciendo lo mismo. Esta paradoja fue un efecto colateral del tiempo que se utilizaba diseñando los CPU, los diseñadores simplemente no tenían tiempo de optimizar cada instrucción posible, y en vez de esto solo optimizaban las más utilizadas. Un famoso ejemplo de esto era la instrucción VAX INDEX, que se ejecutaba más lentamente que un bucle que implementara el mismo código.
Casi al mismo tiempo, las CPU comenzaron a correr a velocidades mayores que las de la memoria con la que se comunicaban. Aún a finales de los setenta, era aparente que esta disparidad continuaría incrementándose al menos durante la siguiente década, para entonces los CPU podrían ser cientos de veces más rápidos que la memoria. Esto significó que los avances para optimizar cualquier modo de direccionamiento serían completamente sobrepasados por las velocidades tan lentas en las que se llevaban a cabo.
Otra parte del diseño RISC llegó desde las medidas prácticas de los programas en el mundo real. Andrew Tanenbaum reunió muchos de estos, demostrando así que la mayoría de los procesadores estaban sobredimensionados. Por ejemplo, él demostró que el 98 % de todas las constantes en un programa podían acomodarse en 13 bits, aun cuando cada diseño de CPU dedicaba algunos múltiplos de 8 bits para almacenarlos, típicamente 8, 16 o 32, una palabra entera. Tomando este hecho en cuenta sugiere que una máquina debería permitir que las constantes fuesen almacenadas en los bits sin utilizar de otras instrucciones, disminuyendo el número de accesos a memoria. En lugar de cargar números desde la memoria o los registros, estos podrían estar ahí mismo para el momento en el que el CPU los necesitara, y por lo tanto el proceso sería mucho más rápido. Sin embargo, esto requería que la instrucción misma fuera muy pequeña, de otra manera no existiría suficiente espacio libre en los 32 bits para mantener constantes de un tamaño razonable.
Fue el pequeño número de modos y órdenes que dio lugar al término conjunto reducido de instrucciones. Esta no es una definición correcta, ya que los diseños RISC cuentan con una vasta cantidad de conjuntos de instrucciones para ellos. La verdadera diferencia es la filosofía para hacer todo en registros y llamar y guardar los datos hacia ellos y en ellos mismos. Esta es la razón por la que la forma más correcta de denominar este diseño es cargar-almacenar. Con el paso del tiempo las técnicas de diseño antiguas se dieron a conocer como Computadora con Conjunto de Instrucciones Complejo, CISC por sus siglas en inglés, aunque esto fue solamente para darles un nombre diferente por razones de comparación.
Por esto la filosofía RISC fue crear instrucciones pequeñas, implicando que había pocas, de ahí el nombre conjunto reducido de instrucciones. El código fue implementado como series de esas instrucciones simples, en vez de una sola instrucción compleja que diera el mismo resultado. Esto hizo posible tener más espacio dentro de la instrucción para transportar datos, resultando esto en la necesidad de menos registros en la memoria. Al mismo tiempo la interfaz con la memoria era considerablemente simple, permitiendo ser optimizada.
Sin embargo RISC también tenía sus desventajas. Debido a que una serie de instrucciones son necesarias para completar incluso las tareas más sencillas, el número total de instrucciones para la lectura de la memoria es más grande, y por lo tanto lleva más tiempo. Al mismo tiempo no estaba claro dónde habría o no una ganancia neta en el desempeño debido a esta limitación, y hubo una batalla casi continua en el mundo de la prensa y del diseño sobre los conceptos de RISC.

Multitarea:
Debido a lo redundante de las microinstrucciones, los sistemas operativos diseñados para estos microprocesadores, contemplaban la capacidad de subdividir un microprocesador en varios, reduciendo el número de instrucciones redundantes por cada instancia del mismo. Con una arquitectura del software optimizada, los entornos visuales desarrollados para estas plataformas, contemplaban la posibilidad de ejecutar varias tareas en un mismo ciclo de reloj. Así mismo, la paginación de la memoria RAM era dinámica y se asignaba una cantidad suficiente a cada instancia, existiendo una especie de 'simbiosis' entre la potencia del microprocesador y la RAM dedicada a cada instancia del mismo.
La multitarea dentro de la arquitectura CISC nunca ha sido real, tal como en los RISC sí lo es. En CISC, el microprocesador en todo su conjunto está diseñado en tantas instrucciones complejas y diferentes, que la subdivisión no es posible, al menos a nivel lógico. Por lo tanto, la multitarea es aparente y por órdenes de prioridad. Cada ciclo de reloj trata de atender a una tarea instanciada en la RAM y pendiente de ser atendida. Con una cola de atención por tarea FIFO para los datos generados por el procesador, y LIFO para las interrupciones de usuario, trataban de dar prioridad a las tareas que el usuario desencadenara en el sistema. La apariencia de multitarea en un CISC tradicional, viene de la mano de los modelos escalares de datos, convirtiendo el flujo en un vector con distintas etapas y creando la tecnología pipeline.
Los microprocesadores actuales, al ser híbridos, permiten cierta parte de multitarea real. La capa final al usuario es como un CISC tradicional, mientras que las tareas que el usuario deja pendientes, dependiendo del tiempo de inactividad, el sistema traducirá las instrucciones (el software ha de ser compatible con esto) CISC a RISC, pasando la ejecución de la tarea a bajo nivel, en donde los recursos se procesan con la filosofía RISC. Dado que el usuario solo atiende una tarea por su capacidad de atención, el resto de tareas que deja pendientes y que no son compatibles con el modelo de traducción CISC/RISC, pasan a ser atendidas por el tradicional pipeline, o si son tareas de bajo nivel, tal como desfragmentaciones de disco, chequeo de la integridad de la información, formateos, tareas gráficas o tareas de cálculo matemático intenso.
En vez de tratar de subdividir a un solo microprocesador, se incorporó un segundo microprocesador gemelo, idéntico al primero. El inconveniente es que la RAM debía de ser tratada a nivel hardware y los módulos diseñados para plataformas monoprocesador no eran compatibles o con la misma eficiencia, que para las plataformas multiprocesador. Otro inconveniente, era la fragmentación del BYTE de palabra. En un RISC tradicional, se ocupan los BYTES de la siguiente forma: Si la palabra es de 32 BITS (4 BYTES de palabra de 8 BITS cada una, o dos de 16 o una de 32), dependiendo de la profundidad del dato portado, dentro del mismo BYTE, se incluían partes de otras instrucciones y datos. Ahora, al ser dos microprocesadores distintos, ambos usaban registros independientes, con accesos a la memoria propios (en estas plataformas, la relación de RAM por procesador es de 1/1). En sus orígenes, las soluciones se parecían a las típicas ñapas de albañil, cada placa base incorporaba una solución solamente homologada por la chip set usada y los drivers que la acompañaban. Si bien la fragmentación siempre ha sido como ese mosquito que zumba en el oído, pero que por pereza permitimos que nos pique, llegó un momento que era imposible evadir el zumbido. Esta época llegó con las plataformas de 64 BITS.

Historia:
Mientras la filosofía de diseño RISC se estaba formando, nuevas ideas comenzaban a surgir con un único fin: incrementar drásticamente el rendimiento de la CPU.
Al principio de la década de los ochenta se pensaba que los diseños existentes estaban alcanzando sus límites teóricos. Las mejoras de la velocidad en el futuro serían hechas con base en procesos mejorados, esto es, pequeñas características en el chip. La complejidad del chip podría continuar como hasta entonces, pero un tamaño más pequeño podría resultar en un mejor rendimiento del mismo al operar a más altas velocidades de reloj. Se puso una gran cantidad de esfuerzo en diseñar chips para computación paralela, con vínculos de comunicación interconstruidos. En vez de hacer los chips más rápidos, una gran cantidad de chips serían utilizados, dividiendo la problemática entre estos. Sin embargo, la historia mostró que estos miedos no se convirtieron en realidad, y hubo un número de ideas que mejoraron drásticamente el rendimiento al final de la década de los ochenta.
Una idea era la de incluir un canal por el cual se pudieran dividir las instrucciones en pasos y trabajar en cada paso muchas instrucciones diferentes al mismo tiempo. Un procesador normal podría leer una instrucción, decodificarla, enviar a la memoria la instrucción de origen, realizar la operación y luego enviar los resultados. La clave de la canalización es que el procesador pueda comenzar a leer la siguiente instrucción tan pronto como termine la última instrucción, significando esto que ahora dos instrucciones se están trabajando (una está siendo leída, la otra está comenzando a ser decodificada), y en el siguiente ciclo habrá tres instrucciones. Mientras que una sola instrucción no se completaría más rápido, la siguiente instrucción sería completada enseguida. La ilusión era la de un sistema mucho más rápido. Esta técnica se conoce hoy en día como Segmentación de cauce.
Otra solución más era utilizar varios elementos de procesamiento dentro del procesador y ejecutarlos en paralelo. En vez de trabajar en una instrucción para sumar dos números, esos procesadores superescalares podrían ver la siguiente instrucción en el canal y tratar de ejecutarla al mismo tiempo en una unidad idéntica. Esto no era muy fácil de hacer, sin embargo, ya que algunas instrucciones dependían del resultado de otras instrucciones.
Ambas técnicas se basaban en incrementar la velocidad al añadir complejidad al diseño básico del CPU, todo lo opuesto a las instrucciones que se ejecutaban en el mismo. Siendo el espacio en el chip una cantidad finita, para poder incluir todas esas características algo más tendría que ser eliminado para hacer hueco. RISC se encargó de tomar ventaja de esas técnicas, esto debido a que su lógica para el CPU era considerablemente más simple que la de los diseños CISC. Aun con esto, los primeros diseños de RISC ofrecían una mejora de rendimiento muy pequeña, pero fueron capaces de añadir nuevas características y para finales de los ochenta habían dejado totalmente atrás a sus contrapartes CISC. Con el tiempo esto pudo ser dirigido como una mejora de proceso al punto en el que todo esto pudo ser añadido a los diseños CISC y aun así caber en un solo chip, pero esto tomó prácticamente una década entre finales de los ochenta y principios de los noventa.

Características:
En pocas palabras esto significa que para cualquier nivel de desempeño dado, un chip RISC típicamente tendrá menos transistores dedicados a la lógica principal. Esto permite a los diseñadores una flexibilidad considerable; así pueden, por ejemplo:

Incrementar el tamaño del conjunto de registros.
Mayor velocidad en la ejecución de instrucciones.
Implementar medidas para aumentar el paralelismo interno.
Añadir cachés enormes.
Añadir otras funcionalidades, como E/S y relojes para minicontroladores.
Construir los chips en líneas de producción antiguas que de otra manera no serían utilizables.
No ampliar las funcionalidades, y por lo tanto ofrecer el chip para aplicaciones de bajo consumo de energía o de tamaño limitado.
Las características que generalmente son encontradas en los diseños RISC son:

Codificación uniforme de instrucciones (ejemplo: el código de operación se encuentra siempre en la misma posición en cada instrucción, la cual es siempre una palabra), lo que permite una decodificación más rápida.
Un conjunto de registros homogéneo, permitiendo que cualquier registro sea utilizado en cualquier contexto y así simplificar el diseño del compilador (aunque existen muchas formas de separar los ficheros de registro de entero y coma flotante).
Modos de direccionamiento simple con modos más complejos reemplazados por secuencias de instrucciones aritméticas simples.
Los tipos de datos soportados en el hardware (por ejemplo, algunas máquinas CISC tiene instrucciones para tratar con tipos byte, cadena) no se encuentran en una máquina RISC.
Los diseños RISC también prefieren utilizar como característica un modelo de memoria Harvard, donde los conjuntos de instrucciones y los conjuntos de datos están conceptualmente separados; esto significa que el modificar las direcciones donde el código se encuentra pudiera no tener efecto alguno en las instrucciones ejecutadas por el procesador (porque la CPU tiene separada la instrucción y el caché de datos, al menos mientras una instrucción especial de sincronización es utilizada). Por otra parte, esto permite que ambos cachés sean accedidos separadamente, lo que puede en algunas ocasiones mejorar el rendimiento.
Muchos de esos diseños RISC anteriores también compartían una característica no muy amable, el slot de salto retardado (Delay Slot). Un slot de salto retardado es un espacio de instrucción siguiendo inmediatamente un salto. La instrucción en este espacio es ejecutada independientemente de si el salto se produce o no (en otras palabra el salto es retardado). Esta instrucción mantiene la ALU de la CPU ocupada por el tiempo extra normalmente necesario para ejecutar una brecha. Para utilizarlo, recae en el compilador la responsabilidad de reordenar las instrucciones de manera que el código sea coherente para ejecutar con esta característica. En nuestros días el slot de salto retardado se considera un desafortunado efecto colateral de la estrategia particular por implementar algunos diseños RISC. Es por esto que los diseños modernos de RISC, tales como ARM, PowerPC, y versiones más recientes de SPARC y de MIPS, generalmente eliminan esta característica.

Primeros diseños RISC:

El primer sistema que pudiera ser considerado en nuestros días como RISC no lo era así en aquellos días; era la supercomputadora CDC 6600, diseñada en 1964 por Seymour Cray.
Cray la diseñó como un CPU para cálculos a gran escala (con 74 códigos, comparada con un 8086 400, además de 12 computadores simples para manejar los procesos de E/S (la mayor parte del sistema operativo se encontraba en uno de estos).
El CDC 6600 tenía una arquitectura de carga/almacenamiento con tan solo dos modos de direccionamiento. Había once unidades de canalización funcional para la aritmética y la lógica, además de cinco unidades de carga y dos unidades de almacenamiento (la memoria tenía múltiples bancos para que todas las unidades de carga/almacenamiento pudiesen operar al mismo tiempo). El nivel promedio de operación por ciclo/instrucción era 10 veces más rápido que el tiempo de acceso a memoria.
Los diseños RISC que más se dieron a conocer sin embargo, fueron aquellos donde los resultados de los programas de investigación de las universidades eran ejecutados con fondos del programa DARPA VLSI. El programa VLSI prácticamente desconocido hoy en día, llevó a un gran número de avances en el diseño de chips, la fabricación y aún en las gráficas asistidas por computadora.
Una de las primeras máquinas de carga/almacenamiento fue la minicomputadora Data General Nova, diseñado en 1968 por Edson de Castro. Había un conjunto de instrucciones RISC casi puro, muy similar a la de los procesadores ARM de hoy, sin embargo no ha sido citado como haber influido en los diseñadores del ARM, aunque estas máquinas estaban en uso en la Universidad de Cambridge ComputerLaboratory en la década de 1980.
El proyecto RISC de la Universidad de Berkeley comenzó en 1980 bajo la dirección de David A. Patterson, basándose en la obtención de rendimiento a través del uso de la canalización y un agresivo uso de los registros conocido como ventanas de registros. En una CPU normal se tienen un pequeño número de registros, un programa puede usar cualquier registro en cualquier momento. En una CPU con ventanas de registros, existen un gran número de registros (138 en el RISC-I), pero los programas solo pueden utilizar un pequeño número de estos (32 en el RISC-I) en cualquier momento.
Un programa que se limita asimismo a 32 registros por procedimiento puede hacer llamadas a procedimientos muy rápidas: la llamada, y el regreso, simplemente mueven la ventana de 32 registros actual para limpiar suficiente espacio de trabajo para la subrutina, y el regreso restablece esos valores.
El proyecto RISC entregó el procesador RISC-I en 1982. Consistiendo de solo 44.420 transistores (comparado con promedios de aproximadamente 100 000 en un diseño CISC de esa época) RISC-I solo tenía 32 instrucciones, y aun así sobrepasaba el desempeño de cualquier otro diseño de chip simple. Se continuó con esta tendencia y RISC-II en 1983 tenía 40.760 transistores y 39 instrucciones, con los cuales ejecutaba 3 veces más rápido que el RISC-I.
Casi al mismo tiempo, John Hennessy comenzó un proyecto similar llamado MIPS en la Universidad de Stanford en 1981. MIPS se centraba casi completamente en la segmentación, asegurándose de que ejecutara tan lleno como fuera posible. Aunque la segmentación ya había sido utilizada en otros diseños, varias características del chip MIPS hacían su segmentación mucho más rápida. Lo más importante, y quizá molesto de estas características era el requisito de que todas las instrucciones fueran capaces de completarse en un solo ciclo. Este requisito permitía al canal ser ejecutado a velocidades más altas (no había necesidad de retardos inducidos) y es la responsable de la mayoría de la velocidad del procesador. Sin embargo, también tenía un efecto colateral negativo al eliminar muchas de las instrucciones potencialmente utilizables, como una multiplicación o una división.
El primer intento por hacer una CPU basada en el concepto RISC fue hecho en IBM el cual comenzó en 1975, precediendo a los dos proyectos anteriores. Nombrado proyecto RAN, el trabajo llevó a la creación de la familia de procesadores IBM 801, la cual fue utilizada ampliamente en los equipos de IBM. El 801 fue producido finalmente en forma de un chip como ROMP en 1981, que es la abreviatura de Research Office Products Division Mini Processor. Como implica el nombre, esta CPU fue diseñada para tareas pequeñas, y cuando IBM lanzó el diseño basado en el IBM RT-PC en 1986, el rendimiento no era aceptable. A pesar de esto, el 801 inspiró varios proyectos de investigación, incluyendo algunos nuevos dentro de IBM que eventualmente llevarían a su sistema IBM POWER.
En los primeros años, todos los esfuerzos de RISC eran bien conocidos, pero muy confinados a los laboratorios de las universidades que los habían creado. El esfuerzo de Berkeley se dio a conocer tanto que finalmente se convirtió en el nombre para el proyecto completo. Muchos en la industria de la computación criticaban el que los beneficios del rendimiento no se podían traducir en resultados en el mundo real debido a la eficiencia de la memoria de múltiples instrucciones, y esa fue la razón por la que nadie los estaba utilizando. Pero a comienzos de 1986, todos los proyectos de investigación RISC comenzaron a entregar productos. De hecho, casi todos los procesadores RISC modernos son copias directas del diseño RISC-II.

RISC moderno:
La investigación de Berkeley no fue comercializada directamente, pero el diseño RISC-II fue utilizado por Sun Microsystems para desarrollar el SPARC, por Pyramid Technology para desarrollar sus máquinas de multiprocesador de rango medio, y por casi todas las compañías unos años más tarde. Fue el uso de RISC por el chip de SUN en las nuevas máquinas el que demostró que los beneficios de RISC eran reales, y sus máquinas rápidamente desplazaron a la competencia y esencialmente se apoderaron de todo el mercado de estaciones de trabajo.
John Hennessy dejó Stanford para comercializar el diseño MIPS, comenzando una compañía conocida como MIPS Computer Systems Inc. Su primer diseño fue el chip de segunda generación MIPS-II conocido como el R2000. Los diseños MIPS se convirtieron en uno de los chips más utilizados cuando fueron incluidos en las consolas de juego Nintendo 64 y PlayStation. Hoy son uno de los procesadores integrados más comúnmente utilizados en aplicaciones de alto nivel por Silicon Graphics.
IBM aprendió del fallo del RT-PC y tuvo que continuar con el diseño del RS/6000 basado en su entonces nueva arquitectura IBM POWER. Entonces movieron sus computadoras centrales S/370 a los chips basados en IBM POWER, y se sorprendieron al ver que aun el conjunto de instrucciones muy complejas (que era parte del S/360 desde 1964) corría considerablemente más rápido. El resultado fue la nueva serie System/390 que aún hoy en día es comercializada como zSeries. El diseño IBM POWER también se ha encontrado moviéndose hacia abajo en escala para producir el diseño PowerPC, el cual eliminó muchas de las instrucciones solo IBM y creó una implementación de chip único. El PowerPC fue utilizado en todas las computadoras Apple Macintosh hasta 2006, y está comenzando a ser utilizado en aplicaciones automotrices (algunos vehículos tienen más de 10 dentro de ellos), las consolas de videojuegos de última generación (PlayStation 3, Wii y Xbox 360) están basadas en PowerPC.
Casi todos los demás proveedores se unieron rápidamente. De los esfuerzos similares en el Reino Unido resultó el INMOS Trasputer, el Acorn Archimedes y la línea Advanced RISC Machine, la cual tiene un gran éxito hoy en día. Las compañías existentes con diseños CISC también se unieron a la revolución. Intel lanzó el i860 y el i960 a finales de los ochenta, aunque no fueron muy exitosos. Motorola construyó un nuevo diseño pero no le vio demasiado uso y finalmente lo abandonó, uniéndose a IBM para producir el PowerPC. AMD lanzó su familia 29000 la cual se convirtió en el diseño RISC más popular a principios de los noventa.
Hoy en día los microcontroladores y CPU RISC representan a la vasta mayoría de todos los CPU utilizados. La técnica de diseño RISC ofrece poder incluso en medidas pequeñas, y esto ha venido a dominar completamente el mercado de CPU integrados de bajo consumo de energía. Los CPU integrados son por mucho los procesadores más comunes en el mercado: considera que una familia completa con una o dos computadoras personales puede poseer varias docenas de dispositivos con procesadores integrados. RISC se apoderó completamente del mercado de estación de trabajo. Después del lanzamiento de la SUN SPARCstation los otros proveedores se apuraron a competir con sus propias soluciones basadas en RISC. Aunque hacia 2006-2010 las estaciones de trabajo pasaron a la arquitectura x86-64 de Intel y AMD. Incluso el mundo de las computadoras centrales está ahora basado completamente en RISC.
Esto es sorprendente en vista del dominio del Intel x86 y x86 64 en el mercado de las computadoras personales de escritorio (ahora también en el de estaciones de trabajo), ordenadores portátiles y en servidores de la gama baja. Aunque RISC fue capaz de avanzar en velocidad muy rápida y económicamente.
Los diseños RISC han llevado a un gran número de plataformas y arquitecturas al éxito, algunas de las más grandes:

La línea MIPS Technologies Inc., que se encontraba en la mayoría de las computadoras de Silicon Graphics hasta 2006, y estuvo en las consolas ya descatalogadas Nintendo 64, PlayStation y PlayStation 2. Actualmente se utiliza en la PlayStation Portable y algunos routers.
La serie IBM POWER, utilizado principalmente por IBM en Servidores y superordenadores.
La versión PowerPC de Motorola e IBM (una versión de la serie IBM POWER) utilizada en los ordenadores AmigaOne, Apple Macintosh como el iMac, eMac, Power Mac y posteriores (hasta 2006). Actualmente se utiliza en muchos sistemas empotrados en automóviles, routers, etc, así como en muchas consolas de videojuegos, como la PlayStation 3, Xbox 360 y Wii.
El procesador SPARC y UltraSPARC de Sun Microsystems y Fujitsu, que se encuentra en sus últimos modelos de servidores (y hasta 2008 también en estaciones de trabajo).
El PA-RISC y el HP/PA de Hewlett-Packard, ya descatalogados.
El DEC Alpha en servidores HP AlphaServer y estaciones de trabajo AlphaStation, ya descatalogados.
El ARM – El paso de hardware de instrucciones x86 en operaciones RISC llega a ser significativo en el área y la energía para dispositivos móviles e integrados. Por lo tanto, los procesadores ARM dominan en PALM, Nintendo DS, Game Boy Advance y en múltiples PDAs, Apple iPods, Apple iPhone, iPod Touch (Samsung ARM1176JZF, ARM Cortex-A8, Apple A4), Apple iPad (Apple A4 ARM -based SoC), videoconsolas como Nintendo DS (ARM7TDMI, ARM946E-S), Nintendo Game Boy Advance (ARM7TDMI).
El Atmel AVR usado en gran variedad de productos, desde mandos de la Xbox a los coches de la empresa BMW.
La plataforma SuperH de Hitachi, originalmente usada para las consolas Sega Super 32X, Saturn y Dreamcast, ahora forman parte del corazón de muchos equipos electrónicos para el consumo.SuperH es la plataforma base del grupo Mitsubishi - Hitachi. Estos dos grupos, unidos en 2002, dejaron aparte la propia arquitectura RISC de Mitsubishi, el M32R.
Los procesadores XAP usados en muchos chips wireless de poco consumo (Bluetooth, wifi) de CSR.